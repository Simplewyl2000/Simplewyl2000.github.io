<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows Objects and Poll Allocations</title>
    <link href="/2020/03/10/Windows-Objects-and-Poll-Allocations/"/>
    <url>/2020/03/10/Windows-Objects-and-Poll-Allocations/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-Objects-and-Poll-Allocations"><a href="#Windows-Objects-and-Poll-Allocations" class="headerlink" title="Windows Objects and Poll Allocations"></a>Windows Objects and Poll Allocations</h1><blockquote><p>​    All the artifacts that you find in memory dumps share a common origin: They all start out as an allocation. How, when, and why the memory regions were allocated sets them apart, in addition to the actual data stored within and around them. From a memory forensics perspective, studying these characteristics can help you make inferences about the content of an allocation, leading to your ability to find and label specific types of data throughout a large memory dump. Furthermore, becoming familiar with the operating system’s algorithms for allocation and de-allocation of memory can help you understand the context of data when you find it—for example, whether it is currently in use or marked as free. </p><p>​    This chapter introduces you to the concepts of Windows executive objects, kernel pool allocations, and pool tag scanning. Specifically, you will use this knowledge to find objects (such as processes, files, and drivers) by using a method that is independent of how the operating system enumerates the objects. Thus, you can defeat rootkits that try to hide by manipulating the operating system’s internal data structures. Furthermore, you can identify objects that were used but have since been discarded (but not overwritten), giving you valuable insight into events that occurred in the past.</p></blockquote><h3 id="windows对象"><a href="#windows对象" class="headerlink" title="windows对象"></a>windows对象</h3><p>我对windows的对象理解就是说：</p><p>windows的对象是windows用于管理的资源的手段，object中相当于存了相关资源的handler，特权级等信息</p><p>然后object是由object manager管理的。</p><p>一般的object</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307101217704.png" srcset="/img/loading.gif" alt="image-20200307101217704"></p><h4 id="对象头部"><a href="#对象头部" class="headerlink" title="对象头部"></a>对象头部</h4><p>对象头部包括 _OBJECT_HEADER 和 可选头部，对于不同的object可选头部是不一样的。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307101614544.png" srcset="/img/loading.gif" alt="image-20200307101614544"></p><p>先看一下_OBJECT_HEADER </p><pre><code>&gt;&gt;&gt; dt(&quot;_OBJECT_HEADER&quot;)&#39;_OBJECT_HEADER&#39; (56 bytes)0x0 : PointerCount [&#39;long long&#39;]0x8 : HandleCount [&#39;long long&#39;]0x8 : NextToFree [&#39;pointer64&#39;, [&#39;void&#39;]]0x10 : Lock [&#39;_EX_PUSH_LOCK&#39;]0x18 : TypeIndex [&#39;unsigned char&#39;]0x19 : TraceFlags [&#39;unsigned char&#39;]0x1a : InfoMask [&#39;unsigned char&#39;]0x1b : Flags [&#39;unsigned char&#39;]0x20 : ObjectCreateInfo [&#39;pointer64&#39;, [&#39;_OBJECT_CREATE_INFORMATION&#39;]]0x20 : QuotaBlockCharged [&#39;pointer64&#39;, [&#39;void&#39;]]0x28 : SecurityDescriptor [&#39;pointer64&#39;, [&#39;void&#39;]]0x30 : Body [&#39;_QUAD&#39;]</code></pre><p>具体含义:</p><ul><li><p>pointercounter：所有的对该应用的引用，包括内核引用</p></li><li><p>TypeIndex: Object type object(后面会提到)的数组索引，这里可以理解为是确定这个object是什么类型的object</p></li><li><p>InfoMask: 包含了哪些可选头部</p></li><li><p>SecurityDescriptor: 有关安全信息，比如哪些用户可以访问这个对象</p></li></ul><p>对于可选头部，同一类型的每个对象可能不同。</p><p>一些可选头部:<br><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307102304096.png" srcset="/img/loading.gif" alt="image-20200307102304096"></p><p>其中的bit mask 应该就是对应到之前的infomask</p><h4 id="Object-type-object"><a href="#Object-type-object" class="headerlink" title="Object type object"></a>Object type object</h4><p>对象类型对象，什么意思呢，可以理解为对这种类型对象的一个概括吧，也就是说对象类型对象中存储了对应的对象的一些基本信息，有点像抽象类。</p><p>header中的TypeIndex就是一个索引，这个索引指的就是该对象类型在nt!ObTypeIndexTable这个array中的序号，从而指出这个对象是什么类型。</p><p>书中一段话</p><blockquote><p>For example, process handle table entries (see Chapter 6) point to object headers. Thus, when you enumerate entries in a handle table, the type of data that follows the header is arbitrary—it could be a _FILE_OBJECT, _EPROCESS, or any other executive object. You can distinguish between the various possibilities by looking at the TypeIndex value, locating the _OBJECT_TYPE that corresponds to the index, and then evaluating the Name member. Refer to Table 5-1 for the mappings between object type names and their structure names. </p></blockquote><p>其中的process handle table 就是学到过的进程中对于资源的一些句柄表(类似于文件打开表，但不限于文件)，比如开了一个文件，文件object的句柄就会存在这个进程中，当然我们也知道，我们打开文件之后不仅仅是在当前进程的handle table中加入handle，而且要在系统打开表中加入这个handle对吧，而这个系统打开表，就是之后要提到的pool。</p><p>object type 的结构</p><pre><code>&gt;&gt;&gt; dt(&quot;_OBJECT_TYPE&quot;)&#39;_OBJECT_TYPE&#39; (208 bytes)0x0 : TypeList [&#39;_LIST_ENTRY&#39;]0x10 : Name [&#39;_UNICODE_STRING&#39;]0x20 : DefaultObject [&#39;pointer64&#39;, [&#39;void&#39;]]0x28 : Index [&#39;unsigned char&#39;]0x2c : TotalNumberOfObjects [&#39;unsigned long&#39;]0x30 : TotalNumberOfHandles [&#39;unsigned long&#39;]0x34 : HighWaterNumberOfObjects [&#39;unsigned long&#39;]0x38 : HighWaterNumberOfHandles [&#39;unsigned long&#39;]0x40 : TypeInfo [&#39;_OBJECT_TYPE_INITIALIZER&#39;]0xb0 : TypeLock [&#39;_EX_PUSH_LOCK&#39;]0xb8 : Key [&#39;unsigned long&#39;]0xc0 : CallbackList [&#39;_LIST_ENTRY&#39;]</code></pre><p>其中:</p><p>Name: 对象的Unicode编码</p><p>TotalNumberOfObjects：该object type对应的类型对象在系统中的数目</p><p>TotalNumberOfHandles：对于该种类型对象的总handler个数。</p><p>TypeInfo：这是一个_OBJECT_TYPE_INITIALIZER结构，其中包含了运用那种内存来分配这个Object，比如分页或是不分页</p><p>Key: 这是个很关键的数据，这个就是我们之后要提到的tag，一个四字节的tag来标识不同的object，比如proc代表process类型object</p><p>我们可以通过objectscan来看对应的OBJECT_TYPE在内存中的偏移</p><p>eg:</p><pre><code> python vol.py -f win7x64cmd.dd --profile=Win7SP0x64 objtypescan</code></pre><h3 id="池分配"><a href="#池分配" class="headerlink" title="池分配"></a>池分配</h3><p>我感觉，windows 的 pool 就是内核的堆吧，跟堆类似，在这段内存存的时候前面都会带一个_POOL_HEADER</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307111031984.png" srcset="/img/loading.gif" alt="image-20200307111031984"></p><p>再看一下_POOL_HEADER的结构</p><pre><code>&gt;&gt;&gt; dt(&quot;_POOL_HEADER&quot;)&#39;_POOL_HEADER&#39; (16 bytes)0x0 : BlockSize [&#39;BitField&#39;, {&#39;end_bit&#39;: 24, &#39;start_bit&#39;: 16, &#39;native_type&#39;: &#39;unsigned long&#39;}]0x0 : PoolIndex [&#39;BitField&#39;, {&#39;end_bit&#39;: 16, &#39;start_bit&#39;: 8, &#39;native_type&#39;: &#39;unsigned long&#39;}]0x0 : PoolType [&#39;BitField&#39;, {&#39;end_bit&#39;: 32, &#39;start_bit&#39;: 24, &#39;native_type&#39;: &#39;unsigned long&#39;}]0x0 : PreviousSize [&#39;BitField&#39;, {&#39;end_bit&#39;: 8, &#39;start_bit&#39;: 0, &#39;native_type&#39;: &#39;unsigned long&#39;}]0x0 : Ulong1 [&#39;unsigned long&#39;]0x4 : PoolTag [&#39;unsigned long&#39;]0x8 : AllocatorBackTraceIndex [&#39;unsigned short&#39;]0x8 : ProcessBilled [&#39;pointer64&#39;, [&#39;_EPROCESS&#39;]]0xa : PoolTagHash [&#39;unsigned short&#39;]</code></pre><p>其中，</p><p>BlockSize: 这个是指分配的空间大小，包括一堆header，这个倒是跟堆一样，头中大小是包含整个的。</p><p>PoolType: 指分配了哪种内存，分页或是不分页</p><p>PoolTag: 这就是我们之前说到的tag，相当于是类的一个标记吧，我们在做psscan的时候就是扫描内存找这个玩意，然后找到proc，确定这里是process project，在win8之后，这个四字节的tag其中会有一个叫做protected bit的东西。</p><h4 id="分配对象的API"><a href="#分配对象的API" class="headerlink" title="分配对象的API"></a>分配对象的API</h4><pre><code class="C">PVOID ExAllocatePoolWithTag( _In_ POOL_TYPE PoolType,                               In_ SIZE_T NumberOfBytes, _In_ ULONG Tag );</code></pre><p>PoolType是指分配类型，是分页还是不分页，</p><blockquote><p>As previously shown, most, but not all, executive object types are allocated using nonpageable memory—and you can always make the distinction by looking at a particular object’s _OBJECT_TYPE.TypeInfo.PoolType member.</p></blockquote><p>Tag 就是之前提到的那个玩意，tag确定了用什么函数，多态？</p><blockquote><p>The Tag argument specifies a four-byte value, typically composed of ASCII characters that should uniquely identify the code path taken to produce the allocation (so troublesome blocks can be traced back to their source). In the case of executive objects, the tags are derived from the _OBJECT_TYPE.Key member—which explains why the Tag is the same for all objects of a particular type</p></blockquote><p>分配对象的API 的一个流程，拿文件object举个例子：</p><ol><li>进程调用CreateFileA (ASCII) or CreateFileW (Unicode)，这俩都是从kernel32中导出的</li><li>然后这俩货之后会指向ntdll.dll, 最终倒向原生函数NtCreateFile</li><li>NtCreatFile会调用ObCreateObject去创建新的文件对象</li><li>ObCreateObject计算文件对象的大小</li><li>ObCreateObject找到对应的OBJECT_TYPE结构然后确定tag是哪个</li><li>最后调用刚刚提到的ExAllocatePoolWithTag，分配</li><li>之后一个指向对象头部的指针就加入到该进程的文件打开表中，系统的pooltag跟踪数据库(系统打开表)也会更新。</li></ol><p>Question</p><blockquote><p> a system-wide pool tag tracking database is updated accordingly, and the individual members of the _FILE_OBJECT are initialized with the path to the file being created and the requested access permissions </p></blockquote><p>这个system-wide pool tag tracking database或者说是系统打开表具体是指什么?</p><h4 id="对象的释放"><a href="#对象的释放" class="headerlink" title="对象的释放"></a>对象的释放</h4><p>跟大多数对象一样，分配之后释放，只是取消占用，但是不会抹除，所以会在内存驻留一段时间。所以释放的对象还是可以被侦测到的。</p><blockquote><p>Exactly how long the memory block lingers in this state depends on the activity level of the system. If the machine is thrashing, and the sizes of blocks being requested are less than or equal to the size of _FILE_OBJECT, it will be overwritten quickly. Otherwise, the object could persist for days or weeks—long after the process that created the file  Windows Objects and Pool Allocations 129 has terminated. In the past, students frequently asked this: After a network connection is closed, how soon must memory be acquired in order to preserve the evidence? The answer is that it’s unpredictable and can vary per machine or even time of day</p></blockquote><p>重要角色登场：</p><h3 id="POOL-TAG-SCANNIG"><a href="#POOL-TAG-SCANNIG" class="headerlink" title="POOL TAG SCANNIG"></a>POOL TAG SCANNIG</h3><p>其实我感觉挺憨的，就是在内存中遍历，找tag</p><p>文中自己也说了，如果光找tag肯定是不够的，还要配上一些相关信息，比如块大小等等，这里给出了一般的tag配套的信息。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307115449961.png" srcset="/img/loading.gif" alt="image-20200307115449961"></p><p>这里讲一下之前提到的protected bit，这是为了保证操作系统不会误操作而提供的，当在释放这个对象的时候，必须提供跟分配时候一样的的protected bit，防止误操作，感觉挺迷的这个操作，详见书P130</p><p>注意到，这个tag实际上是用于Windbg的(实际上去掉或者修改这些并不会影响运行), 所以Windbg中给出了对pooltag的表述，我们可以看每个版本的windows的dbg下的pooltag.txt, 这个文件描述了该版本windows下的pooltag</p><p>还有对应的工具PoolMon，用来监视系统中的pooltag，</p><pre><code>C:\WinDDK\7600.16385.1\tools\Other\i386&gt; poolmon.exe -b</code></pre><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307120552514.png" srcset="/img/loading.gif" alt="image-20200307120552514"></p><p>一段解释(翻译不动了，好累啊我晕了)：</p><p>As you can see, CM31 ranks highest in byte count. Since the system started, there have been 169,392 calls to ExAllocatePoolWithTag for the CM31 tag, and 153,744 of them have been freed. This leaves the difference of 15,648 currently allocated blocks, together consuming 74,838,016 bytes (approximately 75MB) of memory. On average, that’s 4,782 bytes per allocation</p><p>注意到，这个poolmon是用于正在运行的机器上的，但如果我们只有一段内存快照可以么？也是可以的，因为里面有poolmon需要的 kernel debugger data block ( <strong>_KDDEBUGGER_DATA64</strong>) ，记住这个名词！</p><p>这个block 中存了活动的进程以及加载的模块，具体一点，其中的 PoolTrackTable成员指向了一个数组，其中是 _POOL_TRACKER_TABLE 结构，这个结构记录了使用中的tag和其信息。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307121139267.png" srcset="/img/loading.gif" alt="image-20200307121139267"></p><hr><p><strong>Attention</strong></p><p>我觉得这个就是之前我想问的系统打开表，但是问题又来了，既然有系统打开表存在，我们为什么需要去扫描整个内存去找到这些OBbect呢?</p><hr><p>继续，</p><p>这个key就是tag哈, 我们的使用：</p><pre><code>$ python vol.py -f win7x64.dd pooltracker                     --profile=Win7SP0x64                     --tags=Proc,File,Driv,Thre</code></pre><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307121308812.png" srcset="/img/loading.gif" alt="image-20200307121308812"></p><p>接下来就说了怎么去写一个poolscanner，这比较简单，详见P136</p><p>这里给个demo</p><pre><code class="python">1 class PoolScanProcess(poolscan.PoolScanner):2 &quot;&quot;&quot;Pool scanner for process objects&quot;&quot;&quot;34 def __init__(self, address_space, **kwargs):5     poolscan.PoolScanner.__init__(self, address_space, **kwargs)67     self.struct_name = &quot;_EPROCESS&quot;8     self.object_type = &quot;Process&quot;9     self.pooltag = obj.VolMagic(address_space).ProcessPoolTag.v()10    size = self.address_space.profile.get_obj_size(&quot;_EPROCESS&quot;)1112     self.checks = [13     (&#39;CheckPoolSize&#39;, dict(condition = lambda x: x &gt;= size)),14     (&#39;CheckPoolType&#39;, dict(non_paged = True, free = True)),15      (&#39;CheckPoolIndex&#39;, dict(value = 0)),16     ]</code></pre><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307121706505.png" srcset="/img/loading.gif" alt="image-20200307121706505"></p><blockquote><p>If you scan using a physical address space, the code starts looking for the four-byte pool tag at offset 0 of the memory dump file and continues until it reaches the end of the file. Otherwise, if a virtual address space is selected, it enumerates and scans all pages in the kernel’s page table</p></blockquote><p>书中也给出psscan的短处，详见书P141</p><p>不是故意让psscan找不到的的:</p><ul><li>Untagged pool memory: 有些API分配object的时候，是不需要打标签的</li><li>False positives：</li><li>Large allocations：大块分配跟小块分配(指之前我们看到的Object结构)不同</li></ul><p>故意让psscan找不到:</p><ul><li>Arbitrary tags</li><li>Decoy tags：假标签</li><li>Manipulated tags：认为篡改标签</li></ul><h3 id="Big-page-pool"><a href="#Big-page-pool" class="headerlink" title="Big page pool"></a>Big page pool</h3><p>来介绍一下刚刚提到的大块</p><p>Windows 的kernel pool也喜欢将类似大小的块放在一起（应该是为了方便随机访问），这一点跟堆是类似的。然后有些巨大的块(大于4096字节)就是单独放的，就不会加header，用之前提到的big page track table 来索引</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307122942559.png" srcset="/img/loading.gif" alt="image-20200307122942559"></p><h4 id="Big-Page-Track-table"><a href="#Big-Page-Track-table" class="headerlink" title="Big Page Track table"></a>Big Page Track table</h4><p>哇竟然找到了我之前那个问题的答案</p><blockquote><p>the pool track tables ( _POOL_TRACKER_TABLE) for small memory blocks store statistics regarding the number of allocations and byte usage; but they don’t tell you the addresses of all the allocations (thus the need to scan)</p></blockquote><p>但是大表就不一样，他存储了大块的分配位置，所以甚至可以拿它来定位大块而不需要scan。</p><blockquote><p>Unfortunately, the kernel symbol nt!PoolBigPageTable, which points to the array of _POOL_TRACKER_BIG_PAGES structures, (one for each large allocation), is neither exported nor copied to the kernel debugger data block. However, we discovered that this symbol can always be found at a predictable location relative to nt!PoolTrackTable (which is copied to the debugger data block). Thus, if you can find the pool track tables, you can find the big page track tables easily.</p></blockquote><p>大表在小表旁边</p><p>看一下大表的结构</p><pre><code>&gt;&gt;&gt; dt(&quot;_POOL_TRACKER_BIG_PAGES&quot;)&#39;_POOL_TRACKER_BIG_PAGES&#39; (24 bytes)0x0 : Va [&#39;pointer64&#39;, [&#39;void&#39;]]0x8 : Key [&#39;unsigned long&#39;]0xc : PoolType [&#39;unsigned long&#39;]0x10 : NumberOfBytes [&#39;unsigned long long&#39;]</code></pre><p>va就是大块的位置</p><blockquote><p>Keep in mind that although this structure stores the pool tag, it is in a completely different location from the allocation, which is pointed to by Va. For small allocations, the pool tag is contained within the allocation (recall what you saw in Figure 5-4).</p></blockquote><p>接下来就是介绍了一下有关大表的插件，这个没什么好看的。</p><h3 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h3><p>因为poolscan有他不足的地方，所以还有其他方法</p><h4 id="Dispatcher-Header-Scan"><a href="#Dispatcher-Header-Scan" class="headerlink" title="Dispatcher Header Scan"></a>Dispatcher Header Scan</h4><p>总的来说就是利用系统存的一些同步信息来定位object，同步信息是指一些比如同步进程线程用的标志之类的。</p><p>但是缺点也很明显，就是非同步的object就无法scan， 比如文件object</p><h4 id="Robust-Signature-Scans"><a href="#Robust-Signature-Scans" class="headerlink" title="Robust Signature Scans"></a>Robust Signature Scans</h4><p>这个是指很多我们之前scan的tag是无关紧要的，就是说修改或是去掉都不影响运行，所以很多时候attacker会修改或者去掉这些，所以我们需要找无法修改的更加鲁棒的信息，这是一些人通过每次改变一个值的fuzz来找到的，发现有些信息被篡改之后就会蓝屏，所以就找这些信息来查找。</p><p>对应到volatility的插件是psscan3，但是这个不在默认包中，需要自己去下载</p><p>有这些鲁棒信息:<br> • DTB alignment: The DirectoryTableBase must be aligned on a 32-bit boundary. •     Granted access flags: The GrantedAccess member must have the 0x1F07FB flags set.</p><p> • Pointer validity: The VadRoot, ObjectTable, ThreadListHead, and ReadyListHead members must all contain valid kernel mode addresses.</p><p> • Working set list: The VmWorkingSetList member must not only point in kernel mode but it also needs to be above 0xC0000000 (for 32-bit systems). </p><p> • Lock counts: The WorkingSetLock and AddressCreationLock counts must be equal to 1.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>windows为了管理资源(进程，文件等)，为他们创建了Object，这些Object可以理解为他们的档案，然后Object也有分类，就好像把军队分成了后勤，医疗。而对于这些后勤，医疗的描述就是用Object type object来描述。所有的这些归中央军委Object manager管。</p><p>我们现在要寻找在战场(RAM)中找到一些突击兵，查看是否是间谍，我们一个一个扫描，我们可以查看他身上带着的四个字节身份证(tag), 发现是突击兵tag之后，再进一步通过其他信息比如身上子弹多少(块大小)等信息进一步确认。</p><p>由于是一些小兵，总部的档案库中不会存放他们打仗时每个人在什么位置，所以要一个一个找，但是一些军官(big page)，会在档案馆中记录他们的位置(big page track table)，只需要找军官的档案就可以</p><p>但是间谍很心机，他会修改自己的一些不影响大局的东西(debug信息)比如造假身份证躲过扫描，所以新一代计算需要利用不可修改的东西来扫描，比如指纹(鲁棒信息)等。</p>]]></content>
    
    
    <categories>
      
      <category>Memory forensics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hunting Malware</title>
    <link href="/2020/03/10/Hunting-Malware/"/>
    <url>/2020/03/10/Hunting-Malware/</url>
    
    <content type="html"><![CDATA[<h1 id="Hunting-Malware-in-Process-Memory"><a href="#Hunting-Malware-in-Process-Memory" class="headerlink" title="Hunting Malware in Process Memory"></a>Hunting Malware in Process Memory</h1><blockquote><p>The previous chapter introduced you to process memory internals and set the foundations for you to deep dive into analysis. Now you’ll see some specific examples of how you can detect malware that hides in process memory by unlinking dynamic linked libraries (DLLs) or using one of four different methods of injecting code. You’ll also learn the fundamentals of dumping processes, libraries, and kernel modules (any portable executable [PE] files) from memory, including samples that are initially packed or compressed.</p></blockquote><p>本章进一步讲了一下Process在内存中的结构，也具体介绍了几种具体的检测恶意代码的方法</p><p>本章内容：</p><ul><li>了解进程内存中能提供该进程细节的信息</li><li>分析进程的堆，从内存取证的角度了解进程在什么情况下会将数据存在堆里</li><li>学习恶意软件如何通过创建新的环境变量存在于内存中</li><li>分析进程的输入输出handle, 从而分析是否被重定向</li><li>学习进程如何加载，放置DLL</li><li>从内存中提取PE文件用于逆向分析</li><li>检测代码植入</li></ul><h2 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h2><p>PEB 这个玩意的地址是在放在 _EPROCESS 的成员，包括了很多有关进程的东西，比如可执行文件的位置，进程的堆指针，对DLL的描述等等。</p><hr><p><strong>Attention</strong></p><p>PEB是存在于用户区域的，__EPROCESS中存的是指向PEB的指针</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310013642325.png" srcset="/img/loading.gif" alt="image-20200310013642325"></p><p>因为存在用户区，所以也容易被修改，所以可能需要VAD来验证。</p><hr><p>看一下具体的结构</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310013938977.png" srcset="/img/loading.gif" alt="image-20200310013938977"></p><ul><li>BeingDebugged：这个位挺关键的，这代表该进程是否正在被debug，有些malware是会开启debug来搞事情的，所以当这个位被置1但是没有合法的debuger在运行的时候，是会发出警告的。</li><li>ImageBaseAddress: 指出了.EXE被加载的位置，之后的procdump用到了这个值去找位置</li><li>Ldr: 指出有关DLL的信息的位置。</li><li>ProcessParameter: 指向程序参数结构，下面介绍</li><li>ProcessHeap: 指出进程堆的位置</li></ul><p>_RTL_PROCESS_PARAMETERS结构:</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310014735744.png" srcset="/img/loading.gif" alt="image-20200310014735744"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310014747335.png" srcset="/img/loading.gif" alt="image-20200310014747335"></p><p>前三个指出了对应的句柄</p><ul><li><p>ImagePathName: 指出了.exe文件在磁盘上的位置，比如C:\Windows\ System32\XXX</p></li><li><p>commondLine: 就是在我们在黑框框里面输入的那些，调用该进程的命令</p></li><li><p>Environment: 指向该进程的环境变量</p></li></ul><p>注意到，我们在PEB中的LDR是一个结构指针，指向了PEB_LDR_DATA，这个结构中存了三个链表的人口，链表中每个元素都是LDR_DATA_TABLE_ENTRY结构。结构描述了有关模块的情况，注意，这里的模块并不止于dll，而且也包括executable。</p><p>三条链:</p><ul><li>InLoadOrderModuleList：按照加载顺序排的一条链，因为可执行部分总是第一个加载所以总是放在第一个。</li><li>InMemoryOrderModuleList: 按照在内存中的分布排的链，因为ASLR所以不一定就是按加载顺序放。</li><li>InInitializationOrderModuleList: 这是按照DLL中的主函数被调用的顺序来排的，因为模块加载上来之后不一定是一加载就调主函数。</li></ul><p>关于这个链中的元素的结构:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310020242131.png" srcset="/img/loading.gif" alt="image-20200310020242131"></p><ul><li>DllBase：存的是加载的模块的基地址</li><li>EntryPoint: 存模块第一条运行的地址</li><li>LoadCount，指的是被加载的次数，就有点像系统文件打开表，打开一次加一次，之后全部关了才能卸下内存</li></ul><h2 id="进程的堆"><a href="#进程的堆" class="headerlink" title="进程的堆"></a>进程的堆</h2><p>一般来说，进程的输入输出的一些数据往往会存在于进程的堆中，所以如果我们要去查找一些输入输出的数据的时候我们需要找到堆的位置。</p><p>书中举了一个查找notepad++输入缓冲区中信息的例子。</p><p>因为这类信息一般存在堆中，所以要定位堆，直接用跟堆有关的插件(heap)即可，在给出的堆中找到其中标志有<strong>extra</strong>的块，其中可能有货，之后用volshell进入这个进程，用db看内存即可</p><hr><p><strong>Question:</strong>    </p><p>​    这个extra实际上是块中的一个标志位: HEAP_ENTRY_EXTRA_PRESENT 位于  _HEAP_ENTRY.Flags 中，至于为什么这个extra能说明问题，作者对于这个也很晕逼</p><blockquote><p>Regardless of the actual meaning of the “extra” flag (we’ve never found a good description) </p></blockquote><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote><p>The variables are organized as multiple NULL-terminated strings, similar to a REG_MULTI_SZ value in the registry. If an attacker manipulates these variables, they can cause the target application to unexpectedly execute a malicious process. </p></blockquote><p>就是我们天天配的那个玩意，虽然我们往往只是改一下或者添加一下path，path是环境变量的一部分</p><p>一般来说环境变量有这些</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310025934803.png" srcset="/img/loading.gif" alt="image-20200310025934803"></p><p>对应到下面就是:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310025445269.png" srcset="/img/loading.gif" alt="image-20200310025445269"></p><p>以上是系统变量和用户变量，关于四种不同的环境变量的相关性质区别</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310025645271.png" srcset="/img/loading.gif" alt="image-20200310025645271"></p><p>而且一般来说，子进程是继承父进程的环境变量的。父进程也可以通过调用CreateProcess指定参数来创建新的环境变量</p><h3 id="攻击进程的环境变量"><a href="#攻击进程的环境变量" class="headerlink" title="攻击进程的环境变量"></a>攻击进程的环境变量</h3><h4 id="修改PATH或者PATHEXT"><a href="#修改PATH或者PATHEXT" class="headerlink" title="修改PATH或者PATHEXT"></a>修改PATH或者PATHEXT</h4><p>​    可以修改PATH或者PATHEXT这个比较好理解，就是修改PATH或者PATHEXT的顺序使得当当要调用的时候先调用了恶意的软件</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030447307.png" srcset="/img/loading.gif" alt="image-20200310030447307"></p><p>变成：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030501147.png" srcset="/img/loading.gif" alt="image-20200310030501147"></p><p>这样就会先找.tmp下的文件，然后在这里放一个恶意软件就可以得到执行</p><p>同理对PATHEXT</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030548250.png" srcset="/img/loading.gif" alt="image-20200310030548250"></p><p>变成:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030621734.png" srcset="/img/loading.gif" alt="image-20200310030621734"></p><p>这样执行一个比如calc的文件，首先执行calc.zzz再执行cala.com, 实现攻击。</p><h4 id="用环境变量作为标记"><a href="#用环境变量作为标记" class="headerlink" title="用环境变量作为标记"></a>用环境变量作为标记</h4><p>很多时候恶意软件通过一些可以全局访问的变量标志自己在系统中的存在(为了不被友军误伤)，就比如Coreflood这个恶意软件，他的核心是一个DLL，但是每个Process只要装载一次，所以对每个加载过的process添加一个独特的string到他的环境变量中去，每次上载之前先看一下有没有先加入这个string，若加入了不上载了。</p><h2 id="标准句柄"><a href="#标准句柄" class="headerlink" title="标准句柄"></a>标准句柄</h2><p>这个标准句柄准确翻译应该是: 标准输入输出异常处理的句柄。</p><p>分析这个句柄是很有用的(就比如我们的实验分析shelly.exe), 因为很多恶意的软件在系统上留后门的方式是这样的:比如在目标主机上开启一个程序,然后这个程序一直在监听某个特定的端口，如果端口来了请求，就新建一个命令行进程交给请求的客户端，然后主机继续监听。</p><p>注意到，敌手可以发起这个请求然后获得这个cmd，然后对系统进行肆意妄为。(实验shelly.exe原理就是这个)</p><h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>DLL全称Dynamic Link libraries，其中包含执行部分和资源，可以被进程加载并在之后享有进程的所有资源: 进程，句柄等等。也因此容易被攻击者利用。</p><p>我们在分析DLL的时候要注意:</p><ul><li>之前的三条链，注意他有没有故意去隐藏自己</li><li>奇怪的加载地址比如:C:\Windows\ system32\sys\kernel32.dll, 或者从非NTFS区加载进来的</li><li>上下文，比如notepad++加载ws2_32.dll 就会比较可疑</li></ul><h3 id="DLL加载"><a href="#DLL加载" class="headerlink" title="DLL加载"></a>DLL加载</h3><ul><li>每个.exe有一个IAT(import address table)来加载需要的dll</li><li>每个dll也有他自己依赖的dll</li><li>runtime load：loadlibiary() 允许程序在运行时加载dll</li><li>代码植入，dll被强行加载到目标进程中去</li></ul><p>​    获取加载的dll，现在微软提供了一些API供使用，也有一些现成的工具来直接用，但需要注意的是，这些工具用的都是遍历loadlist。</p><p>​    所以我们有时要看其他两条链防止攻击者把加载的dll在loadlist中隐藏了</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310112347365.png" srcset="/img/loading.gif" alt="image-20200310112347365"></p><p>我们看一下dlllist遍历这个loadlist的结果</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310105316251.png" srcset="/img/loading.gif" alt="image-20200310105316251"></p><p>​    可以看到.exe先加载，之后是相应的dll加载，注意到loadcount，这个值我们之前提到是指loadlibrary 加载他的次数其中0xffff是指-1，在这里意思是用IAT加载而不是通过loadlibrary</p><p>​    </p><h3 id="检测未连接的DLL"><a href="#检测未连接的DLL" class="headerlink" title="检测未连接的DLL"></a>检测未连接的DLL</h3><p>之前提到了从一条链上解除的技术，对于这个我们可以用其他两条链来交叉验证，但是现在也有了解除三条链的技术，所以必须要有新的方法来找这些隐藏的dll。</p><ul><li>PE file scan: 通过扫描内存中的PE实例，找PE实例可以通过找PE的特殊开头:MZ,但是由于依然是在用户空间，既然malware可以修改list， 他也是可以修改开头的。</li><li>VAD cross-referencing: VAD中包含了该段内存中对应到的硬盘中的映射，比如该段内存的内容包含了哪个文件以及文件的full path。VAD位于内核，所以不能被轻易修改</li></ul><p>介绍一下VAD cross-reference的插件: ldrmudles,</p><p>工作原理:</p><ol><li>首先在VAD中找大节点(往往存mapfile，dll) with PAGE_EXECUTE_WRITECOPY protections, a VadImageMap type, and the Image control flag set.</li><li>然后比较这个VAD节点中的address和在用户内存扫描得出的DllBase(位于_LDR_DATA_TABLE_ENTRY)</li><li>出现在VAD中但是不在扫描结果中的很有可能就是被hide了</li></ol><h2 id="内存中的PE文件"><a href="#内存中的PE文件" class="headerlink" title="内存中的PE文件"></a>内存中的PE文件</h2><p>书中首先指出很难在内存中dump出一份跟执行时一模一样的PE文件，但是提取出来的信息足够分析使用。</p><p>这里提取PE是因为很多PE进行pack，但是放在内存上就没有壳保护了，于是在内存取出来到硬盘上之后可以用于逆向分析</p><p>然后文中还提到了为什么不可以用内存中PE的hash跟硬盘上的hash进行比较得出是否被修改，有很多原因:</p><ul><li>IAT是被添加的(loadlibrary的调用)</li><li>一些section不一定是每次都加载到内存上去，比如.rsrc, 只有在访问的时候才加上去</li><li>存在松弛空间：松弛空间是指，一个section在内存中不一定是正好是一页的整数倍，所以为了对齐(保护方式是按页为单位的，所以不能一个页一部分可写另一部分标记位可写可读可执行)，内存中的PE相对于硬盘是存在很多松弛空间的。</li></ul><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310131908736.png" srcset="/img/loading.gif" alt="image-20200310131908736"></p><h3 id="提取内存中PE的步骤"><a href="#提取内存中PE的步骤" class="headerlink" title="提取内存中PE的步骤"></a>提取内存中PE的步骤</h3><p>我们拿volshell下步骤作为例子</p><p><strong>Step 1.</strong> </p><p>首先用volshell attach到一个指定的进程上，获取该进程的实例，并从中得到PEB，从PEB得到ImageBaseAddress， 康康DOS头</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132756815.png" srcset="/img/loading.gif" alt="image-20200310132756815"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132822860.png" srcset="/img/loading.gif" alt="image-20200310132822860"></p><p><strong>Step 2.</strong></p><p>可以看到标准的签名MZ(4d5a), 然后通过这个头找到NT头</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132931276.png" srcset="/img/loading.gif" alt="image-20200310132931276"></p><p><strong>Step 3.</strong></p><p>得到NT头之后，就豁然开朗了，从中得到各个section的偏移</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133128459.png" srcset="/img/loading.gif" alt="image-20200310133128459"></p><p><strong>Step 4.</strong></p><p>然后根据偏移把各个section写到硬盘上去即可</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133224747.png" srcset="/img/loading.gif" alt="image-20200310133224747"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133232861.png" srcset="/img/loading.gif" alt="image-20200310133232861"></p><p>就得到了dumped.exe</p><h3 id="现有写好的PE提取插件"><a href="#现有写好的PE提取插件" class="headerlink" title="现有写好的PE提取插件"></a>现有写好的PE提取插件</h3><p>这些插件都是基于上面那个原理</p><ul><li><p>procdump: 有两个选项 –pid(通过上面的方法) 或者 –offset(通过_EPROCESS, 这个可以找到不在list中的进程)</p></li><li><p>dlldump: 这个跟procdump的类似但是是提取dll的</p></li><li><p>moddump: 读取kernel module</p><p>详见P242</p></li></ul><p>所有上面三个都需要提供 –dump-dir参数(写到哪里去) –memory(指定是否需要松弛空间)</p><p>例子:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135136944.png" srcset="/img/loading.gif" alt="image-20200310135136944">  </p><p>这里文件的命名都是excutable.PID.exe</p><p>下面这个例子给出了不在pslist中的进程怎么提出来（其中的地址是通过_EPROCESS对象中读出来的):</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135638418.png" srcset="/img/loading.gif" alt="image-20200310135638418"></p><p>下面给出提取dll的例子，这里指定了提出名字中含有crypt的dll。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135543480.png" srcset="/img/loading.gif" alt="image-20200310135543480"></p><p>但是对于一些注入或者隐藏的dll，你没法正常读出来因为不知道名字也不在list上，所以通过得到这个PE的位置然后往后扫描</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135851589.png" srcset="/img/loading.gif" alt="image-20200310135851589"></p><hr><p><strong>Attention!</strong></p><p>注意到，不管是上面的插件也好或是直接遍历的方法也好，若是MZ被修改或是section的位置被修改都会导致出问题。我们可以通过使用vaddump把该进程的相关内存先提出来之后对这个内存做manual fix-up 然后再用IDA去分析</p><hr><h2 id="打包与压缩问题"><a href="#打包与压缩问题" class="headerlink" title="打包与压缩问题"></a>打包与压缩问题</h2><p>为了克服打包和压缩带来的混淆，往往是上载到内存用自带的解压程序解压之后再来分析</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310164832596.png" srcset="/img/loading.gif" alt="image-20200310164832596"></p><p>所以一般的套路是:</p><p>运行在虚拟机下运行：</p><ol><li>拍一个内存快照</li><li>使用procdump</li><li>使用string cat在内存中找字符串</li></ol><hr><p><strong>Question</strong></p><blockquote><p>The layers of obfuscation introduced by packed or compressed binaries are often removed when they load into memory. In almost all cases, before executing the main payload, a self-modifying program decompresses in place, or moves to another address and then decompresses.</p></blockquote><p>这个self-modifying程序是指什么呢?</p><hr><h2 id="Code-injection"><a href="#Code-injection" class="headerlink" title="Code injection"></a>Code injection</h2><p>文中把代码植入分为以下四种</p><ol><li>Remote DLL injection: 恶意进程强制目标进程去通过LoadLibrary从磁盘上加载DLL，但这种注入的前提是DLL必须在磁盘上。</li><li>Remote code injection: 恶意进程直接传代码块(shellcode)给目标进程</li><li>Reflective DLL injection: 恶意进程向目标进程内存空间中写入dll，这个dll自己初始化不需要windows的loader</li><li>Hollow process injection: 恶意进程首先启动一个新的合法的进程实例然后使其suspend，在这个进程恢复之前，他的内存空间是被挖空的，由恶意代码使用。</li></ol><p>下面介绍一下上面提到的几种注入:</p><p>以下进程A为恶意进程，B为目标进程</p><h3 id="远程DLL注入"><a href="#远程DLL注入" class="headerlink" title="远程DLL注入"></a>远程DLL注入</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>进程A将自己设置为debug程序(使能SE_DEBUG_PRIVILEGE)，这使得他可以对其他进程的内存进行读写就好像一个debugger</li><li>进程A通过OpenProcess打开一个进程B 的句柄, 打开的时候请求PROCESS_CREATE_THREAD, PROCESS_VM_OPERATION, PROCESS_VM_WRITE.</li></ol><hr><p>​        注: OpenProcess是打开一个现有的进程，返回其句柄，常用于进程之间的同步</p><hr><ol start="3"><li>进程A通过VirtualAllocEx在B的内存中开辟页，页的保护级别设置为PAGE_READWRITE.</li><li>A向B传输一个string.txt（指出dll在硬盘上的位置），这个string放在之前一步开的空间里</li><li>A通过CreateRemoteThread在B中创建一个新的线程来执行LoadLibrary进而加载在前一步中传过来的dll位置</li><li>直到这一步，注入已经完成了，A把在第3步中开辟的空间free掉</li><li>A调用closeHandle清理现场跑路</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>对于这样一种注入，我们很难分辨出合理加入的dll和被注入的dll，因为不管从哪里看他们可能都是identical的，但总的来说，有这么两种方法来区分他们</p><ol><li>如果注入的dll尝试把自己隐藏起来(比如把自己从链上摘下)，这样就可以根据之前的两种方法来断定他是不是被注入的</li><li>如果被注入dll是被pack的，他需要开辟一块新空间，把解压代码copy过去执行进而执行</li></ol><p><em>这么说来，不作死就好好呆在那里反而最安全</em></p><h3 id="远程代码注入"><a href="#远程代码注入" class="headerlink" title="远程代码注入"></a>远程代码注入</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>前两步跟DLL一样</p><ol start="3"><li>A进程在B进程中分配一片PAGE_EXECUTE_READWRITE的内存，这使得A可以再这里胡作非为(可读可写可执行)</li><li>A传一个代码块给B</li><li>A在B中开一个新的线程去执行刚传的代码块</li></ol><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>介绍一下<strong>malfind</strong>插件！</p><p>先介绍一下malfind 判断是否为inject的标准(同时满足):</p><ul><li>有一片可读可写可执行的内存</li><li>这片内存是private的</li><li>所有的内存都是commit的</li><li>这篇内存存在CPU指令或者PE头</li></ul><hr><p><strong>Question:</strong></p><p>​    正常的代码区域不满足这些条件?</p><hr><p>我们看一下几个例子加深理解:</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310180746809.png" srcset="/img/loading.gif" alt="image-20200310180746809"></p><p>这是malfind找到的一个片段但是我们不能判断他是不是真的注入代码，因为有些时候合理的代码也会满足这类条件。这里是找到了一个PE头</p><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h5><p>接下来的并没有PE头，因为注入的是一块shellcode</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181049499.png" srcset="/img/loading.gif" alt="image-20200310181049499"></p><p>这个很可能是一块注入代码，因为其汇编语言在这里是make sense的，比如跳转地址合理</p><p>MOC EDI, EDI</p><p>PUSH EBP</p><p>代表即将函数调用</p><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h5><p>再看一个正常代码但是被错判的:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181319070.png" srcset="/img/loading.gif" alt="image-20200310181319070"></p><p>因为符合malfind的标准所以被找出来了，为什么说是错判呢，可以看到有Enter 没有 leave， 而且JNO之前没有比较，所以这是无意义的代码片段</p><h5 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h5><p>下面看一个恶意代码伪装自己的例子</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181603923.png" srcset="/img/loading.gif" alt="image-20200310181603923"></p><p>可以看到这里全是0，一眨眼以为是找错了，但是我们看下一页的时候就会发现端倪</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181720248.png" srcset="/img/loading.gif" alt="image-20200310181720248"></p><p>这边就是恶意代码的主函数了。</p><hr><p><strong>Question：</strong><br>书上说这是函数开始，为啥没有call或者JMP啊，是我汇编没学好么 ？。？</p><hr><h4 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h4><p>使用malfind只是缩小范围，然后还要根据自己的经(xia)验(cai)和汇编只是来确定</p><h3 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h3><p>这是前两者的杂交，A向B传递了一个dll</p><p>他有两个优势:</p><ul><li>不需要提前在磁盘里写好，直接通过连接就可以把DLL送入加载区域</li><li>不要调用loadlibrary，也可以避免出现在那三条链中</li></ul><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310182809527.png" srcset="/img/loading.gif" alt="image-20200310182809527"></p><p>可以看得出来是满足malfind的查询条件的。所以也可以用malfind查询</p><h3 id="挖空注入"><a href="#挖空注入" class="headerlink" title="挖空注入"></a>挖空注入</h3><p>之前的三种方法都是在目标进程中开一个新线程来执行恶意代码，但是目标进程仍然是在执行的。这个方法是直接创建一个新的合法进程，在执行之前把其中合法进程的PE占的空间全部free掉，放入恶意代码，然后开始执行但是其他数据结构(PEB)是这个合法进程的，所以依旧会被认作这个合法进程</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310183531474.png" srcset="/img/loading.gif" alt="image-20200310183531474"></p><h4 id="如何挖空进程"><a href="#如何挖空进程" class="headerlink" title="如何挖空进程"></a>如何挖空进程</h4><ol><li>开启一个合法的新进程比如: C:\windows\system32\ lsass.exe, 但是把他的第一个线程给suspend，此时，PEB的相关数据都是lsass.exe</li><li>获取恶意代码，可以从硬盘上也可以从缓冲区中等等</li><li>找到lsass.exe的ImageBase，然后free掉所有的section。此时DLL,堆栈，句柄都是完好的，只不过PE被挖空了</li><li>在lasass.exe中开辟一个新的内存段(可读可写可执行)，然后返回imagebase(可以跟之前一样也可以不一样)</li><li>把恶意代码的PE header 放到这篇内存中去。</li><li>根据header中的section指示加载各个section</li><li>把那个suspend 的线程的开始位置指向刚加载的section中去(AddressOfEntryPoint)</li><li>开始执行, 在lsass.exe的容器中</li></ol><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>我们从PEB上是看不出任何区别的</p><p>注意到他有重新分配内存所以我们应该从VAD的角度来考虑，查看VAD的相关信息，所以当看到有多个相同的进程的时候，比较他们的VAD信息尽管PEB中含的是合法进程的数据，但是VAD真实记录了所有发生在这段内存上的事情！详见P260(就是sample007.mem的解析)</p><p>所以我们可以看一下ldrmodules和VAD中的记录区别</p><hr><p><strong>Question:</strong></p><blockquote><p>Because lsass.exe was unmapped, a name is no longer associated with the region at 0x01000000. But calling NtUnmapViewOfSection (step 3) doesn’t cause the PEB to lose its metadata, so those structures still have a record of the original mapping in the load order and memory order lists P261</p></blockquote><p>没懂这段</p><hr><h2 id="处理dump-出来的内存文件"><a href="#处理dump-出来的内存文件" class="headerlink" title="处理dump 出来的内存文件"></a>处理dump 出来的内存文件</h2><p>​    就是说了下很多时候把dump出来的文件是要处理一下才能放到一些逆向软件中去的，当不清楚dump出的内存的时候，建议用一下impscan得到该文件的一些信息，这里书中也就是笼统的讲了一下。</p>]]></content>
    
    
    <categories>
      
      <category>Memory forensics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Process Memory Internals</title>
    <link href="/2020/03/08/ProcessMemoryInternals/"/>
    <url>/2020/03/08/ProcessMemoryInternals/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-7-Process-Memory-Internals"><a href="#Chapter-7-Process-Memory-Internals" class="headerlink" title="Chapter 7 Process Memory  Internals"></a>Chapter 7 Process Memory  Internals</h1><p>This chapter gives the details about the  process Memory.</p><p>First, we start with</p><h2 id="What-is-in-the-Process-memory"><a href="#What-is-in-the-Process-memory" class="headerlink" title="What is in the Process memory"></a>What is in the Process memory</h2><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200308222601149.png" srcset="/img/loading.gif" alt="image-20200308222601149"></p><p>Actually, Linux has the same component except the DLL.</p><ul><li><p><em>Mapped files and application</em>:  This is the place where the process store data from the disk ( like read(“1.txt”)）</p></li><li><p><em>PEB</em>:  The process’s environment is stored here</p></li></ul><hr><p>We may notice the MmHighestUserAddress, this address vary between different operating  systems.</p><hr><h3 id="API-that-are-used-to-allocate-the-memory"><a href="#API-that-are-used-to-allocate-the-memory" class="headerlink" title="API that are used to allocate the memory"></a>API that are used to allocate the memory</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200308224939441.png" srcset="/img/loading.gif" alt="image-20200308224939441"></p><p>We see from the above picture, no matter heapAlloc or Non-heapAlloc APIs root in the native function NtAllocateVitualMemory(). </p><p><strong>Attention：</strong></p><blockquote><p>Only a few of the APIs allow the programmer full control over permissions for the allocated memory.</p></blockquote><p>  permission includes: readable, writable, executable</p><p>One important API is VirtualAllocEx, this is the only API that allows a process allocate memory for another process, thus it is often used by malwares to allocate memory for the shellcode.</p><p><strong>Question:</strong></p><blockquote><p>These two virtual allocation functions are also the only ones that allow the caller to reserve memory (that is, set it aside) before committing it. This allows applications to “save” a large region of virtually contiguous memory for later use, without tying up the underlying physical pages in the meantime P193</p></blockquote><p>what is reserve memory and commit memory？</p><h3 id="Enumerating-Process-Memory"><a href="#Enumerating-Process-Memory" class="headerlink" title="Enumerating Process Memory"></a>Enumerating Process Memory</h3><p>主要讲了一下跟进程相关的内存中的重要结构</p><ul><li>页表: 这个大家都懂，位于UVPT，用于虚拟地址和物理地址转换</li><li>VAD: 这是用于对虚拟页的描述的， 比如一个进程申请了10个页，一个页4K，那么一个VAD就会被创建来描述这40K，如果其中有mapfile的话，VAD也是会有记录的</li><li>工作集: 这是最近被使用过的页的集合</li><li>PFN database: 这跟上面的不同，这是记录每一个物理页状态的database。这个database是一个存放在<strong>KDEBUGGER</strong>_DATA64.MmPfnDatabase中的数组</li></ul><p>接下来就来详细介绍一下页表和VAD</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表的作用就不在里说了，这里主要讲一下关于页表的volatility的插件</p><p>memdump， memmap</p><hr><p>这两个插件可以挖掘出指定进程牵扯到(accessible)的页表，这里的accessible也可能涉及到内核页，但是并不代表该进程可以直接使用该页，而是出于他使用了系统掉用的原因把该页视为accessible。</p><hr><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309005215740.png" srcset="/img/loading.gif" alt="image-20200309005215740"></p><p>这是memdump能拿到的指定进程牵涉到的页，可以看到其中有很多空白，这是指那些被换掉的页</p><p>看一个实际的例子</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309005450013.png" srcset="/img/loading.gif" alt="image-20200309005450013"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309005529399.png" srcset="/img/loading.gif" alt="image-20200309005529399"></p><p>可以看到</p><ul><li>虚拟地址也不是连续的，解释为可能被换了，也有可能没有commit</li><li>有些大小是0x20000的，书上的解释说这个是Page Size Entry pages</li></ul><hr><p>这个PSE在第三章也有提到，但是不是很清楚原理。</p><p>PSE:</p><hr><p>再注意到最右边的DumpfileOffset，因为一段内存可能很大比如8G，但是一个程序不可能全部都用到，所以跟他相关的页其实不多，但是他也有可能不连续的使用比如在1G,6G的位置分别用了一页，但是我们没必要把1G到6G无关的内存全部导出来分析(相当于导出文件把中间的5G压缩了)，所以这个值是指对应的页在导出文件的偏移位置。</p><p>到现在为止，其实你已经拿到有关的页了，但是你还不知道这些页对应到的是什么，比如哪些页是对应mapfile，哪些是对应dll这样，所以接下来有请第二位主角VAD</p><h2 id="VAD"><a href="#VAD" class="headerlink" title="VAD"></a>VAD</h2><p>VAD的全称是virtual address description</p><p>VAD实际上是一个树状结构，说的清楚一点，就有点像一个线段树，每一个节点都是一段内存<strong>，但是！</strong>他不是线段树！！！是一个平衡二叉树，毕竟为了更加快速地查找修改。</p><p>VAD的每一个节点存了这样一些信息:</p><ul><li>这段内存有没有mapfile</li><li>这段内存有多少页</li><li>这段内存的初始保护状态(写，读，执行)</li><li>其他flag值</li></ul><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309011634584.png" srcset="/img/loading.gif" alt="image-20200309011634584"></p><p>上面的图是可以用插件画出来的！-vadtree 插件</p><h3 id="VAD结构"><a href="#VAD结构" class="headerlink" title="VAD结构"></a>VAD结构</h3><p>在进程的_EPROCESS的结构体中，其中有个叫做VadRoot的指针，指向这个VAD的root。</p><p>VAD的节点中当然还要存左右孩子指针。</p><p>分配内存的函数类型和其参数决定了这段内存的性质，也就决定了VAD中的一些信息</p><p>对于不同的系统来说，VAD的节点可能有所不同，但是差别不大，都是分为_MMVAD_SHORT, _MMVAD, _MMVAD_LONG。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309030653676.png" srcset="/img/loading.gif" alt="image-20200309030653676"></p><p>我们先看一下root节点的结构</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309012707661.png" srcset="/img/loading.gif" alt="image-20200309012707661"></p><p>可以看到其中指向的头节点，其类型为_MMADDRESS_NODE</p><p>我们再具体看下VAD 的结构</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309012720197.png" srcset="/img/loading.gif" alt="image-20200309012720197"></p><p>Vpn的意思是Virtual Page Number的意思，用这个开始的页号和结束的页号，我们可以得到整个占用的内存大小</p><p>这个node结构其实不是真正的node结构，是node中基本最基本信息，就像我们之前看到的表，是有三种不同node的</p><p>我们看一下:</p><p>short node</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309013820722.png" srcset="/img/loading.gif" alt="image-20200309013820722"></p><p>regular node</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309013834554.png" srcset="/img/loading.gif" alt="image-20200309013834554"></p><p>large node</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309013857119.png" srcset="/img/loading.gif" alt="image-20200309013857119"></p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309013903634.png" srcset="/img/loading.gif" alt="image-20200309013903634"></p><p>我们可以注意到，跟普通和大节点不一样的是</p><p>小节点没有那个mapfile和dll记录，所以如果要找mapfile或者dll的话不用去小节点里面找</p><p>反过来想，因为小页面就是存可执行代码的多，所以我们在找shellcode的时候，就不会去large或者regular中找，而是到小的里面找(比如下面的VadS或者VadF)</p><p><strong>我们是怎么使用Volatility来区分各个节点的呢?</strong></p><p>我们会发现一个很神奇的事情，这些结构的第一个成员的偏移竟然是负的！！！实际上这是在这个结构之前的PoolTag，来指定这个VAD的类型！按照书上这么说的话，这个VAD应该也是一种object！</p><p>Tag与Node类型对应表</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309015945750.png" srcset="/img/loading.gif" alt="image-20200309015945750"></p><h3 id="VAD-flag"><a href="#VAD-flag" class="headerlink" title="VAD flag"></a>VAD flag</h3><p>flag 是一个在node中的8字节联合</p><p>[0，51)代表了commitCharge， </p><p>[51,52)代表了Nochange</p><p>[52,55)代表了Vad_type</p><p>[55,56)代表了MemCommit</p><p>[56-61)位代表的是Protection</p><p>[61,63)代表了Spare</p><p>[63.64)代表了PrivateMemory</p><p>分别来看下这CommitCharge和Protection</p><h4 id="CommitCharge"><a href="#CommitCharge" class="headerlink" title="CommitCharge"></a>CommitCharge</h4><p>这个代表了在该VAD代表的内存范围中，有多少是被该进程commit的。这个成员跟MemCommit是有点类似的。</p><blockquote><p>MemCommit tells you whether the memory was committed when the virtual allocation API (NtAllocateVirtualMemory) was first called</p></blockquote><p>但是对于书中的这一段话我不是很理解</p><blockquote><p>The reason we care about this field is because historically when code injecting malware sets up the target process’ address space to receive the malicious code, it commits all pages up front—it doesn’t reserve them and then go back and commit them later (although it very well could). Thus, you can use these additional characteristics to help identify injected memory regions.</p></blockquote><h4 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h4><p>这个很好理解，就是各个位分开表示该段内存的之前权限。可以用来帮助判断一段未知内存的大概作用。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309022822680.png" srcset="/img/loading.gif" alt="image-20200309022822680"></p><p><strong>Attention！</strong></p><hr><p>这个保护级别是指刚开始申请的的保护级别，比如一段内存第一次申请的时候是不可执行，这个protection字段就就设置为不可执行，但是第二次申请其中某些页为可执行该VAD中的protection位依旧是保持不可执行的值，但是这段内存中重新被申请的页却是可执行的，因为一开始申请这个VAD的时候，是针对这个范围的所有的页，但是权限这个东西却是以页为单位的。所以其中的页被再申请之后真正的protection变了也不足为奇。</p><hr><h4 id="Private-memory"><a href="#Private-memory" class="headerlink" title="Private memory"></a>Private memory</h4><p>指的是不能被分享以及不能被继承的memory。</p><p>因为mapfile和DLL一般是被share的，所以如果该位被置1了，则很有可能就不是这两种而更有可能是堆栈之类的。</p><blockquote><p>A process’ heaps, stacks, and ranges allocated with VirtualAlloc or VirtualAllocEx are usually marked as private. As previously described, because VirtualAllocEx is used to allocate memory in a remote process, the PrivateMemory member is yet another factor you can look at when looking for injected shell code.</p></blockquote><h3 id="跟VAD有关的插件"><a href="#跟VAD有关的插件" class="headerlink" title="跟VAD有关的插件"></a>跟VAD有关的插件</h3><h4 id="vadinfo"><a href="#vadinfo" class="headerlink" title="vadinfo"></a>vadinfo</h4><p>这个是将有关的全部vad node全部信息打出来</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309024135250.png" srcset="/img/loading.gif" alt="image-20200309024135250"></p><h4 id="vaddump"><a href="#vaddump" class="headerlink" title="vaddump"></a>vaddump</h4><p>将VAD树中的所有内存找出来存到一个文件中去，跟之前的memmap不一样，那个是有压缩的，这个是用0填充了。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309024646347.png" srcset="/img/loading.gif" alt="image-20200309024646347"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309024738938.png" srcset="/img/loading.gif" alt="image-20200309024738938"></p><h4 id="vadtree"><a href="#vadtree" class="headerlink" title="vadtree"></a>vadtree</h4><p>这个之前介绍过了，可以把树画出来</p><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><h3 id="查找内存中的用户名和密码"><a href="#查找内存中的用户名和密码" class="headerlink" title="查找内存中的用户名和密码"></a>查找内存中的用户名和密码</h3><p>这里介绍到了一个函数</p><pre><code class="python">search_ process_memory()</code></pre><p>这是在遍历树的时候到对应的范围查找对应的pattern，找到则返回位置，在这个例子中就是查找&amp;password，&amp;username(浏览器POST的参数)</p><h3 id="Yara插件的应用"><a href="#Yara插件的应用" class="headerlink" title="Yara插件的应用"></a>Yara插件的应用</h3><p>这个插件很强，可以在很多数据中匹配pattern，比如文件或者memory dump。</p><p>因为我们很多直接的搜索是在物理内存上，当数据跨页了就很难找到了，但是这个插件解决了这个问题。而且可以一次匹配多个rule</p><h3 id="在内存中查找宙斯密码的密钥"><a href="#在内存中查找宙斯密码的密钥" class="headerlink" title="在内存中查找宙斯密码的密钥"></a>在内存中查找宙斯密码的密钥</h3><p>这个过程有点复杂，首先逆向要看他的函数调用关系，确定一些必要的指令片段之后用这些指令片段去匹配。</p>]]></content>
    
    
    <categories>
      
      <category>Memory forensics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bayes</title>
    <link href="/2020/03/02/Naive%20Bayes%20&amp;%20Bayes/"/>
    <url>/2020/03/02/Naive%20Bayes%20&amp;%20Bayes/</url>
    
    <content type="html"><![CDATA[<h1 id="Naive-Bayes-amp-Bayes"><a href="#Naive-Bayes-amp-Bayes" class="headerlink" title="Naive Bayes &amp; Bayes"></a>Naive Bayes &amp; Bayes</h1><p>The difference between naive Bayes and Bayes is that naive Bayes assumes that the value of the input feature is independent distributed.</p><p>This a quite strong assumption, and that’s why it is named as naive Bayes.</p><h4 id="Notation-explanation-some-notations-that-will-be-used-in-the-following-blog"><a href="#Notation-explanation-some-notations-that-will-be-used-in-the-following-blog" class="headerlink" title="Notation explanation(some notations that will be used in the following blog)"></a>Notation explanation(some notations that will be used in the following blog)</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216005215134.png" srcset="/img/loading.gif" alt="image-20200216005215134"> means that the j^th feature of the i^th  input.</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216005416391.png" srcset="/img/loading.gif" alt="image-20200216005416391"> means the l^th possible value of the  j^th feature</p><h3 id="Learning-Process"><a href="#Learning-Process" class="headerlink" title="Learning Process"></a>Learning Process</h3><p>The learning process for the Bayes is to ‘learn’ the prior probability and the condition probability.</p><p><strong><em>prior</em></strong> <strong><em>probability</em></strong>:  probability of a certain deed to happen</p><p>Say, something like this:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216004257349.png" srcset="/img/loading.gif" alt="image-20200216004257349"></p><p>Condition probability:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216004338052.png" srcset="/img/loading.gif" alt="image-20200216004338052"></p><p>Because the naive Bayes assume that all the feature of one input are independent, so the above formula can be delivered in another way:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216004536707.png" srcset="/img/loading.gif" alt="image-20200216004536707"></p><p>After ‘learn’  the above parameter, then we begin the classification process</p><h3 id="Classification-Process"><a href="#Classification-Process" class="headerlink" title="Classification Process"></a>Classification Process</h3><p>The aim of Bayes model is to classify the input samples into certain categories.</p><p>which means:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216010800035.png" srcset="/img/loading.gif" alt="image-20200216010800035"></p><p>Intuitively, for all the probability we derive from the formula below, we choose the class which get the max value as the output of x. (Note that the condition probability and the prior probability have been ‘learned’)</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216011137636.png" srcset="/img/loading.gif" alt="image-20200216011137636"></p><p>And according to the basic assumption of the naive Bayes model the formula can also be written in this way:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216011427823.png" srcset="/img/loading.gif" alt="image-20200216011427823"></p><p>Then we choose the class for x:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216011530347.png" srcset="/img/loading.gif" alt="image-20200216011530347"></p><h3 id="How-to-‘learn’-the-parameter"><a href="#How-to-‘learn’-the-parameter" class="headerlink" title="How to ‘learn’ the parameter?"></a>How to ‘learn’ the parameter?</h3><p>We use the MLE (Maximum Likelihood Estimate)</p><p>Because the input and the output are discrete. So we can’t use the  derivative here. </p><p>I leave out the proof  of the following formulas here, those who are interested in that can try it yourself. And I will explain the following formulas in a simpler way</p><p>For the prior probability, we simply count the time of the class  appear in the training dataset, because using this method the parameter will fit the current dataset well. </p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216012308925.png" srcset="/img/loading.gif" alt="image-20200216012308925"></p><p>And the same thing for the condition probability</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216012333606.png" srcset="/img/loading.gif" alt="image-20200216012333606"></p><p>This learning process is quite simple as you see above. It’s funny to call it a learning process., so I add quotation marks to the word learn. XD</p><h3 id="Bayes-model"><a href="#Bayes-model" class="headerlink" title="Bayes model"></a>Bayes model</h3><p>It is easy to for us to notice a problem from the above method that we perfunctorily assume that classes that haven’t appear in the dataset have the zero probability to happen!</p><p> Therefore we introduce the Laplace Smoothing:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216014417115.png" srcset="/img/loading.gif" alt="image-20200216014417115"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216014427826.png" srcset="/img/loading.gif" alt="image-20200216014427826"></p><p>In these two equations, for those classes that haven’t appear in the dataset, the probability will  not be zero.   </p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.828 Lab1</title>
    <link href="/2020/03/01/Lab1%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <url>/2020/03/01/Lab1%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Lab1-预备知识"><a href="#Lab1-预备知识" class="headerlink" title="Lab1 预备知识"></a>Lab1 预备知识</h1><p>首先我们要知道在80386下的三种模式</p><ul><li>实模式</li><li>保护模式不分页</li><li>保护模式分页</li></ul><p>我们以这样一道题来看一下这些模式的区别和特点</p><blockquote><p>  已知:<br>  GDT和LDT的首地址分别为55600000H和00013000H，FS=000BH CR3=00013000H , ESI=0000125AH，内存有关数据如图所示。执行指令MOV EAX，FS:[ESI]，求：<br>1.PE=0时源操作对应的物理地址及EAX中的值<br>2.PE=1且PG=0时源操作对应的物理地址及EAX中的值<br>3.PE=1且PG=1时源操作对应的物理地址及EAX中的值</p></blockquote><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303213846736.png" srcset="/img/loading.gif" alt="image-20200303213846736"></p><p>我们先看一下实模式</p><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p>​    我们都知道在早期的8086系列是20位地址1M，但是只有16位地址线的计算机是怎么做到20位寻址的呢：段加偏移。</p><p>​    在80386实模式下，我们依旧是段加偏移来进行寻址。</p><p>​    所以对于上面那道题，我们是将</p><p>​    <strong>段地址*16 + 偏移地址得到地址。</strong></p><p>再来看一下保护模式不分页的情况</p><h3 id="保护模式不分页"><a href="#保护模式不分页" class="headerlink" title="保护模式不分页"></a>保护模式不分页</h3><p>首先介绍一下386下的五个控制寄存器</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303214159372.png" srcset="/img/loading.gif" alt="image-20200303214159372"></p><p>其中</p><p>PE: 是否进入保护模式, PG: 是否启动分页。<br>CD:允许cache，WT：cache是否通写。<br>TS、EM、MP、NE：浮点运算单元控制。<br>AM：内存访问对准检查。WP：对管理程序的专用页进行写保护。</p><p>所以题中的意思就是保护模式不分页了，我们继续。</p><p>在保护模式下，之前给出的FS就不再是基址而是<strong>段选择字</strong></p><p>在介绍段选择字之前我们先看一下什么是<strong>GDTR，GDT</strong>什么是<strong>LDTR, LDT</strong></p><p>GDT全称全局描述符表，他存储的是操作系统的段和LDT的基址, GDTR存的就是GDT的基址</p><p>LDT全称局部描述符表，他存的是局部段的描述符表，相应的LDTR存的就是LDT的基址</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303215557351.png" srcset="/img/loading.gif" alt="image-20200303215557351"></p><p>可以看到界限是16位，但是一个描述符8字节，所以一共是8K个描述符</p><p>接下来我们看一下描述符的结构</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303215733691.png" srcset="/img/loading.gif" alt="image-20200303215733691"></p><p>在知道这些之后我们来看一下段选择字</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303215857302.png" srcset="/img/loading.gif" alt="image-20200303215857302"></p><p>其中的索引就是在选择符表中的位置，正好是13位，TI是指是GDT还是LDT，RPL是特权级对应0,1,2,3</p><p>好了我们总结一下，<strong>保护模式下的段给出的不是基址而是段选择字，其中的索引让我们找到GDT/LDT下的对应描述符。找到描述符之后拿到基址和其他相关信息。基址再加上偏移量得到(都是32位)32位的线性地址</strong></p><p>就得到下图</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303220341628.png" srcset="/img/loading.gif" alt="image-20200303220341628"></p><p>所以第二问是这么做的:</p><p>PE=1且PG=0即不分页的保护方式，因此,使用段描述符找段基地址：段描述符地址=GDT首地址(GDTR中)+索引值*8=55600000H+0008H=55600008H</p><p>故：段描述符=014449 00700001FFH，其中段基地址=01007000H，因此物理地址=线性地址（PG=0）=段基地址+偏移地址=0100825AH，EAX=12009966H</p><p><strong>接下来我们考虑分页</strong></p><h3 id="保护模式分页"><a href="#保护模式分页" class="headerlink" title="保护模式分页"></a>保护模式分页</h3><blockquote><p>我们看到的是段，操作系统看到的是页</p></blockquote><p>关于页的作用这里就不多说了，如果要学习参见<a href="https://www.icourse163.org/course/HIT-1002531008" target="_blank" rel="noopener">哈尔滨工业大学李治军教授mooc</a></p><p>直接上图</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200303220811057.png" srcset="/img/loading.gif" alt="image-20200303220811057"></p><p>可能会有疑惑为什是46位，这里的46是指14+32， 14= 13(索引)+1(TI)</p><p>以上就是基础知识介绍</p>]]></content>
    
    
    <categories>
      
      <category>Operating system</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PDF structure</title>
    <link href="/2020/02/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2020/02/26/PDF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="PDF文件结构解析"><a href="#PDF文件结构解析" class="headerlink" title="PDF文件结构解析"></a>PDF文件结构解析</h1><p>发现国内对于PDF文件的解析比较少，最近看了一篇PDF malware的文章，正好在这里记录一下PDF文件结构的学习。</p><p>先给出官方文档:<a href="https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf" target="_blank" rel="noopener">传送门</a></p><h3 id="大体结构"><a href="#大体结构" class="headerlink" title="大体结构"></a>大体结构</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302203235953.png" srcset="/img/loading.gif" alt="image-20200302203235953"></p><p>以上就是PDF的四个基本结构，先大概叙述一下这几个的作用</p><p>Header：负责表示版本号，Header的格式基本是固定的</p><p>Body：这是PDF的主要content的位置</p><p>Xref：用于各个object的随机访问，存的是各个object的开始位置距离文件开始的偏移，object是PDF一个存储内容unit。</p><p>Trailer: 这是PDF解释器的入口，存了一些入口信息，比如root， info(关于整个文件的信息比如object数目)，Xref的偏移位置等等。</p><p><strong>工作流程</strong></p><p>其主要的工作流程是从Trailer(虽然他在文件的最后，但确实是从这里开始)开始，读取相关信息，找到root，之后遍历这棵树，根据节点的信息和Xref提供的偏移来定位一个一个object之后输出。</p><p>我们按照工作流程介绍一下各个部分叭。</p><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>先给出一个Trailer的示例：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302204133258.png" srcset="/img/loading.gif" alt="image-20200302204133258"></p><p>其中的 &amp;lt 和 &amp;gt分别代表的是&lt; 和 &gt;，一个trailer由一&lt;&lt;和&gt;&gt; 包裹起来的。</p><p>看看其中包含的信息</p><p>我们从后往前看</p><p><strong>EOF:</strong>文件结束符，这个就没什么好说的8</p><p><strong>startxref 和 24212</strong>：startxref这是指明接下来的一行是xref的偏移位置</p><p>之后我们看一下trailer内部的信息、</p><p>/Size(整数类型): 指明了在xref中的object的个数，包括更新与之前的总个数</p><p>/Prev(整数类型): 当不止一个Xref表的时候(因为更新，所以往往不止一个Xref)，这个值是前一个Xref表的偏移位置</p><p>/Root(字典类型)：指出了文件类型object树的根节点是哪一个object，从这个object往下是可以得到整个树的。</p><p>/Encryption(字典类型): 指出了文件的加密字典(关于这个我也没懂，详见官方文档)</p><p>/Info(字典类型): 指明那个object存的是文件的信息</p><p>/ID(数组)： 用两个字节的未加密数据来指明这个文件的ID，从而不需要解密之后再来判断是不是打开的是我们想要的文件。</p><h3 id="Xref"><a href="#Xref" class="headerlink" title="Xref"></a>Xref</h3><p>同样的，我们从一个例子入手</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302210607574.png" srcset="/img/loading.gif" alt="image-20200302210607574"></p><p>我们打开可以看到，其中…是省略了许多，要不然太长了。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302210633069.png" srcset="/img/loading.gif" alt="image-20200302210633069"></p><p>上图的数据用notepad++打开pdf就可以看到。</p><p>我们从上往下看一下</p><p>首先</p><ul><li><p>xref的意思是下面我要说明交叉引用表了。</p></li><li><p>0 233的意思是</p><p>这个表从0号object开始，总共有233个object。</p></li><li><p>再接下来的0000000000 65535 f</p><p>先介绍一下结构，第一个是该object的偏移位置，第二是更新号，第三个是占用状态。</p><p>第一个object的版本号永远是65535，其余所有的刚开始的时候版本号都是0</p><p>f代表是free，没有被占用是可以删除的，n代表不可以删除，正在使用。</p><ul><li><p>其中，所有的f是构成一个单向循环链表的，当是f的时候第一个值不再代表偏移，而是下一个free object 的序号，最后一个又指回0。如下图</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302211706553.png" srcset="/img/loading.gif" alt="image-20200302211706553"></p></li></ul></li></ul><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>首先需要说一下PDF中的数据结构，总共是八大类，包括布尔，数字，数组等等。当然所有这些都是object。</p><p>这里就不一一列举了，有需要的可以看一下文档。</p><p>简单说一下Stream和Indirect Object。</p><h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302212108250.png" srcset="/img/loading.gif" alt="image-20200302212108250"></p><p>steam往往是用来存大块数据如图片这样的。</p><p>length: 说明有多少字节在这个流中</p><p>type：流中文件的细节</p><p>Filter：指定一个filter来处理流中的数据</p><p>DecoderParms: filter的参数</p><p>以及一些其他的参数</p><h4 id="Indirect-Object"><a href="#Indirect-Object" class="headerlink" title="Indirect Object"></a>Indirect Object</h4><p>这实际上不能说是一个数据类型，就是一个引用，硬要说的话有点像指针吧。</p><p>首先要知道所有这些的基本数据只要给出标识号是都可以被当做indirect object的。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302213840317.png" srcset="/img/loading.gif" alt="image-20200302213840317"></p><p>上面是一个基本的包含数字的obj</p><p>他的引用是：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302213910875.png" srcset="/img/loading.gif" alt="image-20200302213910875"></p><p>加上R即可。</p><p>接下来再介绍一下Body的整体解雇，还记得我们之前提到的root么，就是这个树根</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302214011536.png" srcset="/img/loading.gif" alt="image-20200302214011536"></p><p>其中的page tree就是包含的内容结构辣。</p><p>其中root这个object的信息会有以下：</p><ul><li><p>/type：指的是节点类型, 在这里当然就是document catalog了</p></li><li><p>/version: 指的是PDF版本类型</p></li><li><p>/pagetree：指的是Pagetree 的根节点</p></li><li><p>其他(还挺多的，查查文档8)</p></li></ul><p>接下来来看看pagetree的结构</p><ul><li>/type：在这里就是pages了</li><li>/kids：在这里是数组，数组中存的是孩子节点的序号</li><li>/parent：父节点</li><li>/count：该节点下的后代节点个数</li></ul><p>看看一个pagetree的例子</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302214615468.png" srcset="/img/loading.gif" alt="image-20200302214615468"></p><p>以上就是一些基本的知识啦，有什么问题还请指正，谢谢谢谢！</p><p>原文:<a href="https://resources.infosecinstitute.com/pdf-file-format-basic-structure/#gref" target="_blank" rel="noopener">https://resources.infosecinstitute.com/pdf-file-format-basic-structure/#gref</a></p>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVM</title>
    <link href="/2020/01/25/SVM/"/>
    <url>/2020/01/25/SVM/</url>
    
    <content type="html"><![CDATA[<h1 id="SVM的一点心得"><a href="#SVM的一点心得" class="headerlink" title="SVM的一点心得"></a>SVM的一点心得</h1><h3 id="支持向量机公式推导"><a href="#支持向量机公式推导" class="headerlink" title="支持向量机公式推导"></a>支持向量机公式推导</h3><img src="https://pic2.zhimg.com/80/v2-17ea1d3c2532f3df5db77f39484acaad_hd.jpg" srcset="/img/loading.gif" alt="img" style="zoom:50%;" /><p>首先明确，在虚线上的点被称为支持向量</p><p>好，知道这点之后往后看</p><p>为了使得分类效果较好，我们往往希望支持向量到分类面的距离d1,d2 可以最大，</p><p>于是有了算这个决策面的方法</p><p><strong>首先看距离公式</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=d+%3D+%5Cfrac%7B%7C%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D%2B%5Cgamma%7C%7D%7B%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7C%7D" srcset="/img/loading.gif" alt="[公式]"></p><p>这是在高中学过的距离公式</p><p>其中，w，x是向量，w对应到二维平面就是斜率咯</p><p><strong>再看约束条件</strong></p><p><img src="https://www.zhihu.com/equation?tex=y_i+%3D+%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%2B1+%26+%5Ctextrm%7Bfor+blue+points%7D%5C%5C-1+%26+%5Ctextrm%7Bfor+red+points%7D%5Cend%7Barray%7D%5Cright." srcset="/img/loading.gif" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D+%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%3E0+%26+%5Ctextrm%7Bfor~~%7D+y_i%3D1%5C%5C%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%3C0+%26+%5Ctextrm%7Bfor~~%7D+y_i%3D-1%5Cend%7Barray%7D%5Cright." srcset="/img/loading.gif" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D+%28%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%29%2F%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7C%5Cgeq+d+%26+%5Cforall~+y_i%3D1%5C%5C%28%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%29%2F%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7C%5Cleq+-d+%26+%5Cforall~y_i%3D-1%5Cend%7Barray%7D%5Cright." srcset="/img/loading.gif" alt="[公式]"></p><p>这里注明一下，这个d是一个常量，应该理解为d1这样，要跟之后的d相区分，是指支持向量到决策面距离</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D+%5Cboldsymbol%7B%5Comega%7D_d%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma_d%5Cgeq+1+%26+%5Ctextrm%7Bfor~~%7D+y_i%3D1%5C%5C%5Cboldsymbol%7B%5Comega%7D_d%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma_d%5Cleq+-1+%26+%5Ctextrm%7Bfor~~%7D+y_i%3D-1%5Cend%7Barray%7D%5Cright." srcset="/img/loading.gif" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7B%5Comega%7D_d+%3D+%5Cfrac%7B%5Cboldsymbol%7B%5Comega%7D%7D%7B%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7Cd%7D%2C~~+%5Cgamma_d+%3D+%5Cfrac%7B%5Cgamma%7D%7B%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7Cd%7D" srcset="/img/loading.gif" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D+%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%5Cgeq+1+%26+%5Ctextrm%7Bfor~~%7D+y_i%3D1%5C%5C%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%5Cleq+-1+%26+%5Ctextrm%7Bfor~~%7D+y_i%3D-1%5Cend%7Barray%7D%5Cright." srcset="/img/loading.gif" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=d+%3D+%5Cfrac%7B%7C%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%7C%7D%7B%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7C%7D%3D%5Cfrac%7B1%7D%7B%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7C%7D%2C~~%5Ctextrm%7Bif%7D+~%5Cboldsymbol%7Bx%7D_i+%5Ctextrm+%7Bis+a+support+vector%7D+" srcset="/img/loading.gif" alt="[公式]"></p><p>​    看到这里，稍微解释一下，只有是支持向量才能将上半部分替换为1，于是扩大d的方法就是得到w的最小值</p><p><img src="https://www.zhihu.com/equation?tex=y_i%28%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%29%5Cgeq+1~%5Cforall+%5Cboldsymbol%7Bx%7D_i" srcset="/img/loading.gif" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+%5Cmin_%7B%5Cboldsymbol%7B%5Comega%7D%2C%5Cgamma%7D%5Cfrac%7B1%7D%7B2%7D%7C%7C%5Cboldsymbol%7B%5Comega%7D%7C%7C%5E2%5C%5C+~%5C%5C+%5Ctextrm%7Bs.+t.%7D~+~y_i%28%5Cboldsymbol%7B%5Comega%7D%5ET%5Cboldsymbol%7Bx%7D_i%2B%5Cgamma%29%5Cgeq+1%2C~~i+%3D+1%2C2%2C...%2Cm+%5Cend%7Barray%7D+" srcset="/img/loading.gif" alt="[公式]"></p><p>注意，这个1/2是为了之后求导方便</p><h3 id="求得最小值"><a href="#求得最小值" class="headerlink" title="求得最小值"></a>求得最小值</h3><p>约束条件下最小值的求解：</p><p><strong>当当当挡</strong>： 微积分上学的拉格朗日乘子法,</p><p>F’x=ƒ’x(x,y)+λφ’x(x,y)=0 </p><p>F’y=ƒ’y(x,y)+λφ’y(x,y)=0</p><p>F’λ=φ(x,y)=0</p><h3 id="SVM-hinge-loss作业有感"><a href="#SVM-hinge-loss作业有感" class="headerlink" title="SVM hinge_loss作业有感"></a>SVM hinge_loss作业有感</h3><p>如何计算SVM的损失呢？</p><p><img src="https://pic3.zhimg.com/80/f7714c6fb06ed6d1f765ba17a696b0de_hd.png" srcset="/img/loading.gif" alt="img"></p><p>标准的hingeloss</p><p>按照这个公式算就可以了</p><p>注意矩阵计算。</p><p>对于梯度就比较有意思了，是这样的：</p><p>比如Xi对应的label是Yi, 当有共C个类时，其中有K个类对损失做了贡献，则减少对应的权重减少的值为Xi，而增加Yi对应的权值，增加的值为K*Xi，为什么是加上Xi呢？因为Xi包含着这个样本的全部特征。如果Xj也对应着分类Yi，则在Xj的梯度计算时，也会从Xj中提取一定量的特征加入到权利 Wyi中（这里Wyi与Wyi实际上是同一个分类的权重）。</p><p><img src="https://pic2.zhimg.com/80/9cf5d79f58ca3c63ea21b6a9c75940f5_hd.png" srcset="/img/loading.gif" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SVD</title>
    <link href="/2019/12/25/SVD%E7%AE%97%E6%B3%95/"/>
    <url>/2019/12/25/SVD%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="SVD算法"><a href="#SVD算法" class="headerlink" title="SVD算法"></a>SVD算法</h1><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305000402197.png" srcset="/img/loading.gif" alt="image-20200305000402197"></p><p>先上一张图。。。</p><p>我们最终的目的就是将目标M矩阵分解成</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305000756768.png" srcset="/img/loading.gif" alt="image-20200305000756768"></p><p>而对于μ1，μ2，就是奇异值，其实是特征值开根号。</p><p>注意到，</p><ul><li>我们可以用几个简单矩阵的加和来表示目标矩阵M</li><li>可以实现小的奇异值去掉，进而实现去噪功能，因为奇异值在这里是可以理解为权重的</li></ul><p>我们来看一下奇异值分解的过程</p><p>首先实现矩阵的两种转置相乘</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305002038668.png" srcset="/img/loading.gif" alt="image-20200305002038668"></p><p>看第二步，VDVT，这是矩阵的对角化操作其中D是对角矩阵而且是W的特征值而且全为正数。</p><p>于是将D拆开成Σ和Σ的转置相乘（其中Σ里的值就是奇异值），也就是说Σ里的值是特征值开根号</p><p>中间加入VTV，因为V是正交矩阵(实数域下正交矩阵就是幺正矩阵)，幺正矩阵的转置等于幺正矩阵的逆。</p><p>这样我们就成功得到了W的分解</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305002457138.png" srcset="/img/loading.gif" alt="image-20200305002457138"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305002528964.png" srcset="/img/loading.gif" alt="image-20200305002528964"></p><p>进一步我们可以看到这个值可以写为（矩阵相乘性质）:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305002543730.png" srcset="/img/loading.gif" alt="image-20200305002543730"></p><p>就达到我们开始的效果了</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305002613163.png" srcset="/img/loading.gif" alt="image-20200305002613163"></p><p>现在有个问题，我们想要实现降维，可以使用svd么? </p><p>不行，因为svd是将一个nxn的矩阵到了一个nxn的矩阵，维度没有变化。</p><p>于是我们有了tsvd，我们选取前k个大的奇异值来实现降维。</p><p>顺便提一下PCA</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305003305743.png" srcset="/img/loading.gif" alt="image-20200305003305743"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200305003314301.png" srcset="/img/loading.gif" alt="image-20200305003314301"></p><p>我们已经找到了所有主成分，在 n 个主成分中选取前 d 维组成我们需要的超平面，并将数据集投影在上面。例如将左图中的三维数据集投影成右图的数据集，在降维的同时，尽可能保留了与原数据集的相似度。投影过程可以通过计算 <img src="https://www.zhihu.com/equation?tex=W_%7Bd%7D" srcset="/img/loading.gif" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=X" srcset="/img/loading.gif" alt="[公式]"> 的点积实现，其中 <img src="https://www.zhihu.com/equation?tex=W_%7Bd%7D" srcset="/img/loading.gif" alt="[公式]"> 是由 <img src="https://www.zhihu.com/equation?tex=+V%5E%7BT%7D+" srcset="/img/loading.gif" alt="[公式]"> 的前 <img src="https://www.zhihu.com/equation?tex=d+" srcset="/img/loading.gif" alt="[公式]"> 列组成的矩阵 </p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OWASP</title>
    <link href="/2019/12/25/OWASP/"/>
    <url>/2019/12/25/OWASP/</url>
    
    <content type="html"><![CDATA[<h1 id="OWASP"><a href="#OWASP" class="headerlink" title="OWASP"></a>OWASP</h1><h2 id="TOP-1-INJECTION"><a href="#TOP-1-INJECTION" class="headerlink" title="TOP 1  INJECTION"></a>TOP 1  INJECTION</h2><ul><li><p>Injection flaws occur when an attacker can send hostile data to an interpreter</p></li><li><p>Injection vulnerabilities are often found in SQL, LDAP, XPath, or NoSQL queries, OS commands, XML parsers, SMTP headers, expression languages, and ORM queries. </p></li></ul><p><strong>example：</strong></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200221160722087.png" srcset="/img/loading.gif" alt="image-20200221160722087"></p><p><strong>How to protect</strong></p><ul><li><p>Preventing injection requires keeping data separate from commands and queries.</p></li><li><p>Use positive or “whitelist” server-side input validation. This is not a complete defense as many applications require special characters, such as text areas or APIs for mobile applications.</p></li></ul><h2 id="TOP-2-BROKEN-AUTHENTICATION"><a href="#TOP-2-BROKEN-AUTHENTICATION" class="headerlink" title="TOP 2 BROKEN AUTHENTICATION"></a>TOP 2 BROKEN AUTHENTICATION</h2><p>ps：字典攻击和暴力破解</p><p><strong>Vulnerable</strong> <strong>when</strong>:</p><ul><li>Permits brute force or other automated attacks</li><li>Permits default, weak, or well-known passwords, such as “Password1” or “admin/admin”</li></ul><p><strong>example</strong>:</p><ul><li><p>Application session timeouts aren’t set properly. A user uses a public computer to access an application. Instead of selecting “logout” the user simply closes the browser tab and walks away. An attacker uses the same browser an hour later, and the user is still authenticated.</p></li><li><p>Credential stuffing, the use of lists of known passwords, is a common attack. If an application does not </p><p>implement automated threat or credential stuffing protections, the application can be used as a password oracle to determine if the credentials are valid.</p></li></ul><p><strong>How to defence</strong></p><ul><li><p>Where possible, implement multi-factor authentication to prevent automated, credential stuffing, brute force, and stolen credential re-use attacks. </p></li><li><p>Limit or increasingly delay failed login attempts. Log all failures and alert administrators when credential stuffing, brute force, or other attacks are detected.</p></li></ul><h2 id="TOP-3-SENSITIVE-DATA-EXPOSURE"><a href="#TOP-3-SENSITIVE-DATA-EXPOSURE" class="headerlink" title="TOP 3 SENSITIVE DATA EXPOSURE"></a>TOP 3 SENSITIVE DATA EXPOSURE</h2><p><strong>Definition</strong></p><p>Rather than directly attacking crypto, attackers steal keys, execute man-in the-middle attacks, or steal clear text data off the server, while in transit, or from the user’s client, e.g. browser. </p><p><strong><em>secret data should not be transited in plain text!</em></strong></p><p><strong>Vulnerable When:</strong></p><ul><li><p>This concerns protocols such as HTTP, SMTP, and FTP. External internet traffic is especially dangerous. Verify all internal traffic e.g. between load balancers, web servers, or back-end systems</p></li><li><p>Are any old or weak cryptographic algorithms used either by default or in older code? </p></li></ul><p><strong>Examples:</strong></p><ul><li><p>An application encrypts credit card numbers in a database using automatic database encryption. However, this data is automatically decrypted when retrieved, allowing an SQL injection flaw to retrieve credit card numbers in clear text.</p></li><li><p>A site doesn’t use or enforce TLS for all pages or supports weak encryption. An attacker monitors network traffic (e.g. at an insecure wireless network), downgrades connections from HTTPS to HTTP, intercepts requests, and steals the user’s session cookie. The attacker then replays this cookie and hijacks the user’s (authenticated) session, accessing or modifying the user’s private data. Instead of the above they could alter all transported data, e.g. the recipient of a money transfer.</p><p>需要端到端加密！end-to-end encryption is needed!</p></li></ul><p><strong>How to protect</strong></p><ul><li><p>Classify data processed, stored, or transmitted by an application. Identify which data is sensitive according to privacy laws, regulatory requirements, or business needs.</p></li><li><p>Apply controls as per the classification.</p></li></ul><h2 id="TOP-4-XML-External-Entities-XXE"><a href="#TOP-4-XML-External-Entities-XXE" class="headerlink" title="TOP 4 XML External Entities (XXE)"></a>TOP 4 <strong>XML External Entities (XXE)</strong></h2><p><strong>Definition</strong></p><p>Attackers can exploit vulnerable XML processors if they can upload XML or include hostile content in an XML document, exploiting vulnerable code, dependencies or integrations. </p><p><strong>Vulnerable</strong> <strong>when</strong>:</p><ul><li><p>The application accepts XML directly or XML uploads, especially from untrusted sources, or inserts untrusted data into XML documents, which is then parsed by an XML processor</p></li><li><p>Being vulnerable to XXE attacks likely means that the application is vulnerable to denial of service attacks including the Billion Laughs attack.</p></li></ul><p><strong>ps: what is the Billion Laughs attack ?</strong></p><p>The example attack consists of defining 10 entities, each defined as consisting of 10 of the previous entity, with the document consisting of a single instance of the largest entity, which expands to one <a href="https://en.wikipedia.org/wiki/1000000000_(number)" target="_blank" rel="noopener">billion</a> copies of the first entity.</p><p>like:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">lolz</span> [</span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol</span> <span class="meta-string">"lol"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ELEMENT <span class="meta-keyword">lolz</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol1</span> <span class="meta-string">"&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol2</span> <span class="meta-string">"&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol3</span> <span class="meta-string">"&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol4</span> <span class="meta-string">"&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol5</span> <span class="meta-string">"&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol6</span> <span class="meta-string">"&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol7</span> <span class="meta-string">"&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol8</span> <span class="meta-string">"&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"</span>&gt;</span></span></span><br><span class="line"><span class="meta"> <span class="meta">&lt;!ENTITY <span class="meta-keyword">lol9</span> <span class="meta-string">"&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lolz</span>&gt;</span>&amp;lol9;<span class="tag">&lt;/<span class="name">lolz</span>&gt;</span></span><br></pre></td></tr></table></figure><p>When an XML parser loads this document, it sees that it includes one root element, “lolz”, that contains the text “&lol9;”. However, “&lol9;” is a defined entity that expands to a string containing ten “&lol8;” strings. Each “&lol8;” string is a defined entity that expands to ten “&lol7;” strings, and so on. After all the entity expansions have been processed, this small (&lt; 1 KB) block of XML will actually contain 109 = a billion “lol”s, taking up almost 3 <a href="https://en.wikipedia.org/wiki/Gigabyte" target="_blank" rel="noopener">gigabytes</a> of memory</p><p><strong>Example:</strong></p><ul><li>The attacker attempts to extract data from the server:</li></ul><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200221173631345.png" srcset="/img/loading.gif" alt="image-20200221173631345"></p><p><strong>How to protect</strong></p><ul><li><p>Verify that XML or XSL file upload functionality validates incoming XML using XSD validation or similar.</p><p>(XSD is the replacement of the DTD)</p></li></ul><h2 id="TOP-5-Broken-Access-Control"><a href="#TOP-5-Broken-Access-Control" class="headerlink" title="TOP 5 Broken Access Control"></a>TOP 5 <strong>Broken Access Control</strong></h2><p><strong>Definition</strong>:</p><p>Access control enforces policy such that users cannot act outside of their intended permissions. Break the control can endow the user some privileges that are not supposed to have </p><p><strong>Vulnerable when</strong>:</p><ul><li>Bypassing access control checks by modifying the URL, internal application state, or the HTML page, or simply using a custom API attack tool</li><li>Elevation of privilege. Acting as a user without being logged in, or acting as an admin when logged in as a user.</li></ul><p><strong>Example：</strong></p><ul><li><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200221175400087.png" srcset="/img/loading.gif" alt="image-20200221175400087"></li></ul><p><strong>How to protect</strong></p><ul><li>With the exception of public resources, deny by default.</li><li>Log access control failures, alert admins when appropriate </li></ul><h2 id="TOP-6-Security-Misconfiguration"><a href="#TOP-6-Security-Misconfiguration" class="headerlink" title="TOP 6 Security Misconfiguration"></a>TOP 6 <strong>Security Misconfiguration</strong></h2><p>个人感觉是个很文学的错误（</p><p>就是感觉这也能算错误？？？跟粗心大意一个意思XD</p><p><strong>Definition:</strong></p><p>Attackers will often attempt to exploit unpatched flaws or access default accounts, unused pages, unprotected files and directories, etc to gain unauthorized access or knowledge of the system.</p><p><strong>Vulnerable when:</strong></p><ul><li><p>Error handling reveals stack traces or other overly informative error messages to users.</p></li><li><p>Unnecessary features are enabled or installed (e.g. unnecessary ports, services, pages, accounts, or privileges).</p></li></ul><p><strong>Example：</strong></p><ul><li>The application server comes with sample applications that are not removed from the production server. These sample applications have known security flaws attackers use to compromise the server. If one of these applications is the admin console, and default accounts weren’t changed the attacker logs in with default passwords and takes over</li></ul><p><strong>How to protect:</strong></p><ul><li>A repeatable hardening process that makes it fast and easy to deploy another environment that is properly locked down. Development, QA, and production environments should all be configured identically, with different credentials used in each environment. This process should be automated to minimize the effort required to setup a new secure environment.</li></ul><h2 id="Cross-Site-Scripting-XSS"><a href="#Cross-Site-Scripting-XSS" class="headerlink" title="Cross-Site Scripting (XSS)"></a><strong>Cross-Site Scripting (XSS)</strong></h2><p><strong>Stored XSS:</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6230889-07ab49e8b1ea148a.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" srcset="/img/loading.gif" alt="img"></p><p><strong>Reflected XSS</strong></p><p>一般是利用用户的输入不做过滤然后直接执行这样，eg：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span> </span></span><br><span class="line"><span class="php">$XssReflex = $_GET[<span class="string">'input'</span>];</span></span><br><span class="line"><span class="php"><span class="keyword">echo</span> <span class="string">'output:&lt;br&gt;'</span>.$XssReflex;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>DOM XSS:</strong></p><p>在很多场景下，业务需要实现页面跳转，常见的使用，<code>location.href()</code> <code>location.replace()</code> <code>location.assign()</code>这些方法通过Javascript实现跳转。我们第一时间可能想到的是限制不严导致任意URL跳转漏洞，而DOM XSS与此似乎“八竿子打不着”，实际上跳转部分参数可控，可能导致Dom xss。</p><p>JavaScript frameworks, single-page applications, and APIs that dynamically include attacker-controllable data to a page are vulnerable to DOM XSS. Ideally, the application would not send attacker-controllable data to unsafe JavaScript APIs.</p><p><strong>Example:</strong></p><p>Take the above Reflected XSS as an example:</p><p>we input the <script>alert('xss')</script>  ：</p><p><img src="https://upload-images.jianshu.io/upload_images/6230889-909939f59402f6b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1001/format/webp" srcset="/img/loading.gif" alt="img"></p><p>it means without the filter, the browser execute the code we input</p><p><strong>How to protect</strong></p><p>Preventing XSS requires separation of untrusted data from active browser content. This can be achieved by</p><ul><li>Using frameworks that automatically escape XSS by design, such as the latest Ruby on Rails, React JS. Learn the limitations of each framework’s XSS protection and appropriately handle the use cases which are not covered.</li></ul><h2 id="TOP-8-Insecure-Deserialization"><a href="#TOP-8-Insecure-Deserialization" class="headerlink" title="TOP 8 Insecure Deserialization"></a>TOP 8 Insecure Deserialization</h2><p>改变运行顺序？</p><p><strong>two types of attack:</strong></p><ul><li><p>Object and data structure related attacks where the attacker modifies application logic or achieves arbitrary remote code execution if there are classes available to the application that can change behavior during or after deserialization.</p></li><li><p>Typical data tampering attacks, such as access-control-related attacks, where existing data structures are used but the content is changed.</p></li></ul><p><strong>Example：</strong></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200221204832056.png" srcset="/img/loading.gif" alt="image-20200221204832056"></p><p><strong>How to protect</strong></p><p>The only safe architectural pattern is not to accept serialized objects from untrusted sources or to use serialization mediums that only permit primitive data types.</p><h2 id="TOP-9-Using-Components-with-Known-Vulnerabilities"><a href="#TOP-9-Using-Components-with-Known-Vulnerabilities" class="headerlink" title="TOP 9 Using Components with Known Vulnerabilities"></a>TOP 9 <strong>Using Components</strong> with Known Vulnerabilities</h2><p>我觉得这是废话，跟同上一样=-=</p><p><strong>when Vulnerable</strong></p><ul><li>If you do not know the versions of all components you use (both client-side and server-side). This includes components you directly use as well as nested dependencies.</li><li>If you do not scan for vulnerabilities regularly and subscribe to security bulletins related to the components you use.</li></ul><p><strong>Example</strong></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200221205313612.png" srcset="/img/loading.gif" alt="image-20200221205313612"></p><p><strong>How to protect:</strong></p><ul><li><p>Remove unused dependencies, unnecessary features, components, files, and documentation.</p></li><li><p>Only obtain components from official sources over secure links. Prefer signed packages to reduce the chance of including a modified, malicious component.</p></li></ul><h2 id="TOP-10-Insufficient-Logging-amp-Monitoring"><a href="#TOP-10-Insufficient-Logging-amp-Monitoring" class="headerlink" title="TOP 10 Insufficient Logging &amp; Monitoring"></a>TOP 10 <strong>Insufficient</strong> Logging &amp; Monitoring</h2><p>Attackers rely on the lack of monitoring and timely response to achieve their goals without being </p><p>detected.</p><p><strong>Vulnerable when：</strong></p><ul><li><p>Auditable events, such as logins, failed logins, and high-value transactions are not logged.</p></li><li><p>Logs of applications and APIs are not monitored for suspicious activity.</p></li><li><p>Warnings and errors generate no, inadequate, or unclear log messages.</p></li></ul><p><strong>Remember</strong>: You are vulnerable to information leakage if you make logging and alerting events visible to a user or an attacker </p><p><strong>Example</strong></p><ul><li>An attacker uses scans for users using a common password. They can take over all accounts using this password. For all other users, this scan leaves only one false login behind. After some days, this may be repeated with a different password.</li></ul><p><strong>How to protect</strong></p><ul><li>Ensure all login, access control failures, and server-side input validation failures can be logged with sufficient user context to identify suspicious or malicious accounts, and held for sufficient time to allow delayed forensic analysis.</li><li>Ensure that logs are generated in a format that can be easily consumed by a centralized log management solutions.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>show Website</title>
    <link href="/2019/11/30/%E4%BB%8E%E4%B8%8A%E7%94%B5%E5%88%B0%E5%B1%95%E7%A4%BA%E7%BD%91%E9%A1%B5/"/>
    <url>/2019/11/30/%E4%BB%8E%E4%B8%8A%E7%94%B5%E5%88%B0%E5%B1%95%E7%A4%BA%E7%BD%91%E9%A1%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="从上电到展示网页"><a href="#从上电到展示网页" class="headerlink" title="从上电到展示网页"></a>从上电到展示网页</h1><ol><li>首先将网卡和以太网线相连</li><li>使用DHCP，此时查找本地的ARP转发表，若无网关对应的mac，则广播，封装成帧，DHPC响应之后，获得IP地址。</li><li>输入google.com</li><li>DNS解析出IP地址</li><li>使用IP地址封装网络层包</li><li>此时查找本地的ARP转发表，若无网关对应的mac，则广播。封装成帧。</li><li>此时开始和google的服务器建立TCP连接</li><li>第三次握手时开始请求数据</li><li>google服务器发送应答</li><li>到达客户端之后浏览器显示页面</li></ol>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network layer</title>
    <link href="/2019/11/26/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%A6%81%E7%82%B9/"/>
    <url>/2019/11/26/%E7%BD%91%E7%BB%9C%E5%B1%82%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="网络层要点"><a href="#网络层要点" class="headerlink" title="网络层要点"></a>网络层要点</h1><h4 id="路由器缓冲区大小设置"><a href="#路由器缓冲区大小设置" class="headerlink" title="路由器缓冲区大小设置"></a>路由器缓冲区大小设置</h4><p>B = RTT *R</p><p>对于N通道</p><p>B = RTT*R/((N)^1/2)</p><h4 id="IP-数据报格式相关位"><a href="#IP-数据报格式相关位" class="headerlink" title="IP 数据报格式相关位"></a>IP 数据报格式相关位</h4><ul><li>总长度: 16位，但是由于在传输的过程中不能大于MTU，所以总长度大于MTU的会被切片，在发送之前会使用ICMP进行对链路层MTU进行测试，总长度是切片之后的长度</li><li>首部长度:首部长度共四位，以<strong>32位即4个字节</strong>为单位，记录了首部的长度，总长度减去首部为数据长度</li><li>标识: 是对数据报进行重组用的ID</li><li>标志: DF=0 -&gt;可以分片, MF=1-&gt;表示后面还有分片</li><li><strong>片偏移</strong>：占13位，但如何表示总长度为16位的呢，片偏移的单位是<strong>8个字节</strong>，所以不足8个字节的需要填充</li><li>首部校验和：是首部的！！无数据部分</li></ul><h4 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h4><table><thead><tr><th>类型</th><th>网络号</th><th>开始</th><th>最后</th><th>主机号</th></tr></thead><tbody><tr><td>A类(0开头)</td><td>8位 共2^7-2</td><td>1</td><td>126</td><td>24位 2^24-2</td></tr><tr><td>B类(10开头)</td><td>16位</td><td>128.1</td><td>191.255</td><td>16位 65534</td></tr><tr><td>C类(110开头)</td><td>24位</td><td>192.0.1</td><td>223.255.255</td><td>8位 254</td></tr></tbody></table><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP不只是能获得IP地址，还可以获得网关地址和DNS地址，子网掩码等相关信息</p><h4 id="NAT中常见的本地地址"><a href="#NAT中常见的本地地址" class="headerlink" title="NAT中常见的本地地址"></a>NAT中常见的本地地址</h4><p>10/8</p><p>172.16/12</p><p>192.168/16</p><p>见到这几个要联想到直接是NAT</p><h4 id="IPV4-与-IPV6"><a href="#IPV4-与-IPV6" class="headerlink" title="IPV4 与 IPV6"></a>IPV4 与 IPV6</h4><p>IPV6 </p><ol><li>无检查和，中间阶段无需计算</li><li>中间节点不再负责分片和重组 ？？？</li><li>首部长度固定，加速中间节点转发</li></ol><h4 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h4><p>地杰斯特拉出现的问题</p><h5 id="OSPF-是一个协议的名称，在此共享链路状态的协议下有链路状态选路。选路算法是迪杰斯特拉"><a href="#OSPF-是一个协议的名称，在此共享链路状态的协议下有链路状态选路。选路算法是迪杰斯特拉" class="headerlink" title="OSPF 是一个协议的名称，在此共享链路状态的协议下有链路状态选路。选路算法是迪杰斯特拉"></a><strong>OSPF</strong> 是一个协议的名称，在此共享链路状态的协议下有链路状态选路。选路算法是迪杰斯特拉</h5><p>OSPF：</p><ol><li>干什么: 向本自治系统中所有的路由器发消息</li><li>发什么: 发的是相邻路由器节点的链路状态</li><li>什么时候发: 链路状态变化的时候或者定时发送</li><li>最后结果: 大家都有了全网的拓扑结构图，全网范围一致</li></ol><p>优点:</p><ol><li>安全</li><li>多条相同开销的路径</li><li>单个AS中支持层次路由</li></ol><h5 id="距离向量选路算法：Internet上的DV算法：RIP协议"><a href="#距离向量选路算法：Internet上的DV算法：RIP协议" class="headerlink" title="距离向量选路算法：Internet上的DV算法：RIP协议"></a>距离向量选路算法：Internet上的DV算法：RIP协议</h5><p>通过<strong>B-F公式</strong></p><p>每个节点只知道自己到其他节点的费用，以及接收其他节点的消息来进行迭代</p><p>对于坏消息传的慢这个问题的理解：</p><ol><li>根本: <ol><li>链路费用的变化无法直接同步到各个节点上去, 有些节点的距离保留着历史信息</li><li>在链路费用发生变化的时候，是通过本地先保存的拓扑结构更新距离向量，若变化则通知这个变化，若不变则进入静止状态</li></ol></li><li>关于毒性逆转:<ol><li>若某节点是通过K节点到T节点的，则返回其直接到T节点的距离为无穷。</li><li>但是对于一般的无穷计数节点较多的时候，是无法解决的。</li></ol></li><li>所以一般使用15跳来解决无穷计数问题</li></ol><h4 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h4><p>AS内部有自己的选路算法</p><p>从一个AS到另一个AS:</p><ol><li>只有一个网关到达，则该网关向AS中路由器通知，其中路由器添加该项目</li><li>多个网关到达，则选一个费用小的网关(热土豆)</li></ol>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAN</title>
    <link href="/2019/11/25/GAN/"/>
    <url>/2019/11/25/GAN/</url>
    
    <content type="html"><![CDATA[<h1 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h1><p>GAN这个东西真的蛮有意思的，中文名叫对抗神经网络，如其名，整个训练过程就是D(discriminator) 和 G(Generator)的对抗，我们来看具体过程</p><p>先笼统的说一下GAN的过程吧：</p><ol><li><p>首先D 拿到真实的数据，然后对应lable都是真，产生对真的score1</p></li><li><p>然后又G来根据随机种子产生图片，丢到D里面去，这时候对应的lable都是假，产生对假的score2</p></li><li><p>有了score1和score2之后就可以计算discriminator的loss了！拿到loss之后进行backward(注意，这里只对D进行更新！！！)</p></li><li><p>将存储在G中的grad清零。</p></li><li><p>然后G再产生一组新的fake image(前面那组专门给D使用)，这组新的Image丢进D然后得到score3</p></li><li><p>使用score3得到G_loss, 然后使用G_loss进行backward，对D中的grad清零，对G进行更新(不对D更新)</p></li><li><p>可以注意到G和D是固定住一端然后更新另一端的。</p><p>总体逻辑类似于下面的图:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206221332383.png" srcset="/img/loading.gif" alt="image-20200206221332383"></p></li></ol><p>在？看看公式:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206215516819.png" srcset="/img/loading.gif" alt="image-20200206215516819"></p><p>上面那个公式就是训练的目标了</p><p>其中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D(x)：指的是对输入x的score，换句话说是对x判断是否为真的可能性</span><br><span class="line"></span><br><span class="line">G(z):   z是随机扰动，G(z)是由G生成的图像</span><br><span class="line"></span><br><span class="line">E：是指期望</span><br></pre></td></tr></table></figure><p>上面那个公式的意思是，G 希望能够减小这个值，也就是说希望能达到以假乱真的结果，也就是希望D(G(z))比较大（意味着产生出来的图片被认为真的可能性很大)</p><p>相反对于D来说，希望能够增大这个值，理由同上</p><h2 id="Conventional-GAN"><a href="#Conventional-GAN" class="headerlink" title="Conventional GAN"></a>Conventional GAN</h2><h3 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206221811538.png" srcset="/img/loading.gif" alt="image-20200206221811538"></p><p>目标是将上面的值变大，我们换到loss下来思考就是负数变小嘛，于是:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206222009334.png" srcset="/img/loading.gif" alt="image-20200206222009334"></p><p>这就是D的<strong>loss</strong>了。</p><p>接下来我们来看下如何实现这两项的期望</p><p>其实就是bce: binary cross entropy 很有名的二分交叉熵了(在二分类中，模型输出的是为true或是false的概率，用true或是false为标签值，之后使用bce得到loss)，仔细一看，这不就是数学期望的定义么=-=</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206223412056.png" srcset="/img/loading.gif" alt="image-20200206223412056"></p><p>接下来我们看看如何计算期望，因为直接这样naive输入是会有不稳定和大于1(输入是score不是概率)的问题，所以这边提供了稳定的方法。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206223641773.png" srcset="/img/loading.gif" alt="image-20200206223641773"></p><p>有了bce的实现之后，看一下D的loss实现</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206225805299.png" srcset="/img/loading.gif" alt="image-20200206225805299"></p><p>那个减一也就是变为0了，也就是说是假的</p><h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p>传统的GAN的D和G结构比较简单:<br>先看看D:<br>线性层-》ReLU-》线性层-》ReLU-》线性层-》TanH</p><p>实现:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206225356369.png" srcset="/img/loading.gif" alt="image-20200206225356369"></p><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206225519069.png" srcset="/img/loading.gif" alt="image-20200206225519069"></p><p>可以看到这里跟D是类似的，但是他是希望能够增加假数据(也就是自己生成的数据)的分数</p><p>具体是这样滴,  减小下面这个loss:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206225629987.png" srcset="/img/loading.gif" alt="image-20200206225629987"></p><p>loss的实现是这样滴：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206225909908.png" srcset="/img/loading.gif" alt="image-20200206225909908"></p><p>这里就只要将标签置为1就可以了。</p><p>然后根据这个loss去更新G即可</p><h4 id="层次结构-1"><a href="#层次结构-1" class="headerlink" title="层次结构"></a>层次结构</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206230118920.png" srcset="/img/loading.gif" alt="image-20200206230118920"></p><p>从噪声进来然后一层一层的全连接输出图片向量</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>训练过程之前在开始已经提过了，基本就是这么个过程了。</p><p>记住一点！GAN的训练过程是</p><p>再提一次:</p><p>在以下步骤中做规定次数的循环:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0. 先将D的grad清零</span><br><span class="line"></span><br><span class="line">1. 首先D 拿到真实的数据，然后对应lable都是真，产生对真的score1</span><br><span class="line"></span><br><span class="line">2. 然后又G来根据随机种子产生图片，丢到D里面去，这时候对应的lable都是假，产生对假的score2</span><br><span class="line"></span><br><span class="line">3. 有了score1和score2之后就可以计算discriminator的loss了！拿到loss之后进行backward(注意，这里只对D进行更新！！！)</span><br><span class="line"></span><br><span class="line">4. 将存储在G中的grad清零。</span><br><span class="line"></span><br><span class="line">5. 然后G再产生一组新的fake image(前面那组专门给D使用)，这组新的Image丢进D然后得到score3</span><br><span class="line"></span><br><span class="line">6. 使用score3得到G_loss, 然后使用G_loss进行backward，对D中的grad清零，对G进行更新(不对D更新)</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207004705039.png" srcset="/img/loading.gif" alt="image-20200207004705039"></p><h2 id="Least-Square-GAN"><a href="#Least-Square-GAN" class="headerlink" title="Least Square GAN"></a>Least Square GAN</h2><p>原理跟前面的一样,这里用距离的平均来表示:<br>D训练中:D预测出的真实数据的值与1应该更接近，预测生成数据的值要与0更接近</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207003207272.png" srcset="/img/loading.gif" alt="image-20200207003207272"></p><p>实现:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207003258729.png" srcset="/img/loading.gif" alt="image-20200207003258729"></p><p>G训练中:G生成出来的值要与1更接近</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207003158773.png" srcset="/img/loading.gif" alt="image-20200207003158773"></p><p>实现:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207003315541.png" srcset="/img/loading.gif" alt="image-20200207003315541"></p><p>这个跟之前的区别我个人感觉就是更通俗易懂而且更稳定了。</p><p>以后要是做GAN的话我必用这一种做loss</p><p>反正记住两种loss吧:</p><ol><li>一种是交叉熵取负数</li><li>第二种是距离</li></ol><p>接下来的更刺激一些</p><h2 id="Deeply-Convolutional-GANs（DCGAN"><a href="#Deeply-Convolutional-GANs（DCGAN" class="headerlink" title="Deeply Convolutional GANs（DCGAN)"></a>Deeply Convolutional GANs（DCGAN)</h2><p>这就是传说中的DCGAN了，</p><p>更之前的区别就在于D,G的结构不一样，其他都是一样的。</p><p>可以注意到，我们之前生成的图片有一个问题就是边缘很模糊这样，所以我们在DCGAN中使用了卷积层的filter来进行特征的提取可以使得效果好很多</p><p>先看一下D的结构，比较好理解:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207004748433.png" srcset="/img/loading.gif" alt="image-20200207004748433"></p><p>只不过是加了两层卷积池化罢了。</p><p>但是在G中就有一个比较有意思的东西了</p><p>先看一下结构:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207004839414.png" srcset="/img/loading.gif" alt="image-20200207004839414"></p><p>可以看到，其中有两个ConvTranspose这个是反卷积：</p><p>因为我们卷积时候把图片特征是提取出来了的，相当于是在压缩图片，但是我们是要将噪声生成可以看的图片，要还回去。但是卷积是不可逆的操作，所以只能还原图片尺度无法还原数值.</p><p>但是我对这个地方的理解也不是很深刻</p><p>反卷积参见:</p><p><a href="https://www.zhihu.com/question/48279880" target="_blank" rel="noopener">https://www.zhihu.com/question/48279880</a></p><p>再看一下DCGAN的效果:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200207005327679.png" srcset="/img/loading.gif" alt="image-20200207005327679"></p>]]></content>
    
    
    <categories>
      
      <category>Deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nmap</title>
    <link href="/2019/11/25/Nmap/"/>
    <url>/2019/11/25/Nmap/</url>
    
    <content type="html"><![CDATA[<h1 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h1><h3 id="最基本的："><a href="#最基本的：" class="headerlink" title="最基本的："></a>最基本的：</h3><p>nmap 域名(IP)</p><p>这个域名解析也可以使用指定的dns-server</p><p>nmap –dns -servers 8.8.8.8 域名</p><h3 id="端口相关"><a href="#端口相关" class="headerlink" title="端口相关"></a>端口相关</h3><p>nmap -pm-n IP：检测m-n的端口</p><p>nmap -p80，135 IP : 检测80端口和135端口的状态</p><p>nmap -p T:25 U:53 IP : 检测tcp的25和udp的53端口</p><p>nmap -p s* IP: 检测s开头协议的所有端口</p><p>nmap -p [1-65535]IP: 检测注册在nmap中的所有端口</p><h3 id="目标机器信息"><a href="#目标机器信息" class="headerlink" title="目标机器信息"></a>目标机器信息</h3><p>nmap -sV IP</p><p>nmap -A -v -T4 IP： 侵略性探测可以识别目标的操作系统等，T4是为了加快速度</p><p>nmap -sC -sV -O IP: 利用脚本进行探测 -sC = –script = default</p><h3 id="局域网主机探测"><a href="#局域网主机探测" class="headerlink" title="局域网主机探测"></a>局域网主机探测</h3><p>nmap -sP CIDR 探测该网络中的存活主机</p><p>nmap -sn CIDR -oX XXX 结果输出到XXX</p><h3 id="使用脚本"><a href="#使用脚本" class="headerlink" title="使用脚本"></a>使用脚本</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200222112100713.png" srcset="/img/loading.gif" alt="image-20200222112100713"></p><p>nmap –script 脚本名称 目标</p><p>nmap -sV –script vuln 目标：扫出有漏洞的端口</p><p>也有指定条件的变形体：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200222112414012.png" srcset="/img/loading.gif" alt="image-20200222112414012"></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Style transfer</title>
    <link href="/2019/11/24/Style%20transfer/"/>
    <url>/2019/11/24/Style%20transfer/</url>
    
    <content type="html"><![CDATA[<h1 id="Style-transfer"><a href="#Style-transfer" class="headerlink" title="Style transfer"></a>Style transfer</h1><p>概述：</p><p>给定一张内容图片，一张风格图片，将内容的图片的风格改为风格图片的内容</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200205213556854.png" srcset="/img/loading.gif" alt="image-20200205213556854"></p><p>因为需要内容相同，并且风格相同，所以可以定义一个loss函数表示风格loss和内容loss的和，同时，为了使得整个图片看得比较正常，我们加入total_variance loss， 使得整个图片更加平滑</p><p>接下来我们来看下如何定义这么几个loss</p><h3 id="Content-Loss"><a href="#Content-Loss" class="headerlink" title="Content Loss"></a>Content Loss</h3><p>我们假设是有已经训练好的CNN模型的</p><p>我们从中取一层的feature作为内容的feature。</p><p>然后将现在图片中的feature和内容的feature比较得出loss，具体公式如下。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200205214321562.png" srcset="/img/loading.gif" alt="image-20200205214321562"></p><p>其中，Wc是给予内容误差的权重</p><p>实现：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200205214420804.png" srcset="/img/loading.gif" alt="image-20200205214420804"></p><h3 id="Style-Loss"><a href="#Style-Loss" class="headerlink" title="Style Loss"></a>Style Loss</h3><p>首先我们先来认识一下Gram</p><p>先看一下Gram的定义：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206113528747.png" srcset="/img/loading.gif" alt="image-20200206113528747"></p><p>​        我们可以理解为Gram矩阵表示了图片的风格。至于为什么，简单理解一下可以理解为是各个filter 的组合，这恰好类似于风格的定义。</p><p><img src="https://pic1.zhimg.com/80/v2-1e6e43b4fc5208d29c57c606f9f5dd10_hd.png" srcset="/img/loading.gif" alt="img"></p><p>​        譬如说，某一层中有一个滤波器专门检测尖尖的塔顶这样的东西，另一个滤波器专门检测黑色。又有一个滤波器负责检测圆圆的东西，又有一个滤波器用来检测金黄色。</p><p>​        对梵高的原图做Gram矩阵，谁的相关性会比较大呢？如上图所示，“尖尖的”和“黑色”总是一起出现的，它们的相关性比较高。而“圆圆的”和“金黄色”都是一起出现的，他们的相关性比较高。</p><p>​        因此在风格转移的时候，其实也在风景图里去寻找这种“匹配”，将尖尖的渲染为黑色，将圆圆的渲染为金黄色。如果我们承认<strong>“图像的艺术风格就是其基本形状与色彩的组合方式”</strong> ，这样一个假设，那么Gram矩阵能够表征艺术风格就是理所当然的事情了。</p><p>​    然后我们就做这样一件事情：</p><p>​    用CNN 提取待产生图片的Gram和风格图片的Gram，两者的差别就是style loss</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206114035846.png" srcset="/img/loading.gif" alt="image-20200206114035846"></p><p>​    这里跟内容不同，内容我们是把其中一层拿出来作差，而在风格这里我们把所有的层的差距做和</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206113956730.png" srcset="/img/loading.gif" alt="image-20200206113956730"></p><p>看一下Gram的实现:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206114353361.png" srcset="/img/loading.gif" alt="image-20200206114353361"></p><p>然后看一下Style Loss</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206114600201.png" srcset="/img/loading.gif" alt="image-20200206114600201"></p><h3 id="Total-variation-regularization"><a href="#Total-variation-regularization" class="headerlink" title="Total-variation regularization"></a>Total-variation regularization</h3><p>之前也提到了，这个是为了增加整个图片的平滑度的，所以周围作差就可以了</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206114748719.png" srcset="/img/loading.gif" alt="image-20200206114748719"></p><p>实现:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tvLoss = tv_weight * (torch.pow(img[:, :, <span class="number">1</span>:] - img[:, :, :<span class="number">-1</span>], <span class="number">2</span>).sum() + torch.pow(img[:, :, :, <span class="number">1</span>:] - img[:, :, :, :<span class="number">-1</span>], <span class="number">2</span>).sum())</span><br><span class="line"><span class="keyword">return</span> tvLoss</span><br></pre></td></tr></table></figure><h3 id="Style-Transfer"><a href="#Style-Transfer" class="headerlink" title="Style Transfer"></a>Style Transfer</h3><p>现在已经有了这三个loss，可以做整个的loss了</p><p>说一下整个的流程:</p><p>首先获取内容某一层的feature</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206115058803.png" srcset="/img/loading.gif" alt="image-20200206115058803"></p><p>之后是获取style 的feature</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206115125743.png" srcset="/img/loading.gif" alt="image-20200206115125743"></p><p>然后初始化图片，我们可以随机生成也可以直接中内容图片上进行修改</p><p>之后就是计算出loss然后进行backward了，这里使用的是Adam规则进行优化参数</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200206115329810.png" srcset="/img/loading.gif" alt="image-20200206115329810"></p>]]></content>
    
    
    <categories>
      
      <category>Deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAN</title>
    <link href="/2019/11/21/RNN%20&amp;%20LSTM/"/>
    <url>/2019/11/21/RNN%20&amp;%20LSTM/</url>
    
    <content type="html"><![CDATA[<h1 id="RNN-amp-LSTM"><a href="#RNN-amp-LSTM" class="headerlink" title="RNN &amp; LSTM"></a>RNN &amp; LSTM</h1><p>先介绍一下这个有名的数据集</p><p><strong>Ms COCO（Common Objects in COntext）</strong></p><p> MS COCO的全称是Microsoft Common Objects in Context，起源于微软于2014年出资标注的Microsoft COCO数据集，与ImageNet竞赛一样，被视为是计算机视觉领域最受关注和最权威的比赛之一。<br>        COCO数据集是一个大型的、丰富的物体检测，分割和字幕数据集。这个数据集以scene understanding为目标，主要从复杂的日常场景中截取，图像中的目标通过精确的segmentation进行位置的标定。图像包括91类目标，328,000影像和2,500,000个label。目前为止有语义分割的最大数据集，提供的类别有80 类，有超过33 万张图片，其中20 万张有标注，整个数据集中个体的数目超过150 万个。</p><p>这边连不上网所以看不了可视化的数据介绍</p><p>开始我们的第一位主角：</p><h2 id="RNN（Recurrent-Neural-Networks）"><a href="#RNN（Recurrent-Neural-Networks）" class="headerlink" title="RNN（Recurrent Neural Networks）"></a>RNN（Recurrent Neural Networks）</h2><p>首先我们可以注意到之前的所有网络都有一个共同的问题就是没有考虑到历史信息或者说各个输入之间的信息，但是对于很多要考虑上下文的处理中这是很致命的，所以诞生了RNN。</p><p>我把这次实验中的网络图先贴出来，用此介绍RNN的结构，图有些潦草为当时帮助自己理解画的</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204032959699.png" srcset="/img/loading.gif" alt="image-20200204032959699"></p><p>​    可以看到图中标注的12个的位置就是RNN了，我们可以先简单这样理解，是12个简单的全连接层，然后中间的一部分结果会从第1传到第12层。这也就实现了一个历史信息的传递。</p><p>好，接下来，看看各个层的实现</p><h3 id="Step-forward"><a href="#Step-forward" class="headerlink" title="Step_forward"></a>Step_forward</h3><p>看RNN的step_forward(其实我觉得这个图很像一位全加器，然后RNN连起来就像多位全加器了):</p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204035051985.png" srcset="/img/loading.gif" alt="image-20200204035051985" style="zoom:25%;" /><p>这个结合历史和输入的神奇公式是这样的：</p><p>out = prev_h @ Wh + x @ Wh + b</p><p>然后：</p><p>输出：tanh(state)</p><p>这时候要注意，Out和Hi的关系. 这个地方的Outi是输出的Hi经过temproal_layer的结果，我这里画出来的Outi实际上不是这层的输出，只是实现连贯性理解。</p><h3 id="Step-Backward"><a href="#Step-Backward" class="headerlink" title="Step_Backward"></a>Step_Backward</h3><p>Backward跟所有的BP都是一样的. 求导咯</p><p>这里给出了dnext_h，然后往回链式求导</p><p>实现：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204035605412.png" srcset="/img/loading.gif" alt="image-20200204035605412"></p><h3 id="RNN-MODEL-FORWARD"><a href="#RNN-MODEL-FORWARD" class="headerlink" title="RNN_MODEL_FORWARD"></a>RNN_MODEL_FORWARD</h3><p>这个比较简单，只要能理解Rnn的结构即可，将每一次迭代的历史信息传递给下一次迭代</p><p>实现：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204035904383.png" srcset="/img/loading.gif" alt="image-20200204035904383"></p><h3 id="RNN-MODEL-BACKWARD"><a href="#RNN-MODEL-BACKWARD" class="headerlink" title="RNN_MODEL_BACKWARD"></a>RNN_MODEL_BACKWARD</h3><p>​    由于写好了基本的反向层，只要一层一层传就可以了。但是要注意到，历史信息是会向前传递的，所以，导数是需要往回传的。</p><p>所以会有一个这样的累加：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204040202384.png" srcset="/img/loading.gif" alt="image-20200204040202384"></p><p>所以实现:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204040234237.png" srcset="/img/loading.gif" alt="image-20200204040234237"></p><p>对于输入的词语，我们要以向量的形式输入</p><h3 id="word-embedding"><a href="#word-embedding" class="headerlink" title="word_embedding"></a>word_embedding</h3><p><strong>forward</strong></p><p>这是一个这样的层，首先是 N x T 个词语的输入</p><p>然后embedding层是一个 V x D 的层</p><p>然后这个 N x T 中的值是在[0, V]</p><p>所以将N x T 个单词中替换成 N x T 个V维的向量</p><p>这个embedding的权重也是需要更新的</p><p>实现上很简单:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204041201681.png" srcset="/img/loading.gif" alt="image-20200204041201681"></p><p><strong>backward</strong></p><p>这个embeding的backward，也是有点意思的，注意到这个函数np.add.at意思是在对应的位置加上指定的值。</p><p>实现:</p><p>np.add.at(dW, x.flatten(), dout.reshape(-1, D))</p><p>也就是说在对应的单词权重上加上梯度</p><h3 id="temporal-affine"><a href="#temporal-affine" class="headerlink" title="temporal_affine"></a>temporal_affine</h3><p>然后就是基本的全连接层了，将传递的历史信息传出来的层</p><p>这个就不介绍了</p><h2 id="IN-amp-OUT"><a href="#IN-amp-OUT" class="headerlink" title="IN &amp; OUT"></a>IN &amp; OUT</h2><p>我想说一下这个输入输出</p><p>现在有一组captions。</p><p>比如: 我 真的 睡不着 觉</p><p>RNN的目的是判断下一个单词的输出</p><p>这样我们把数据分成两组，输入和输出</p><p>输入：我 真的 睡不着</p><p>输出：真的 睡不着 觉</p><p>然后输出可以作为label然后然后算loss回传</p><p>​     推出</p><p>我 ——-》 真的</p><p>真的 ——》 睡不着</p><p>睡不着 ——》觉</p><p>然后还要注意一个问题: 因为输出的长度不定，所以会有Null填充， 但是Null又不能作为一个损失，所以要有一个mask来标记，此处是否为NULL, 然后决定损失上要不要加他。</p><p>接下来有请下一位主角LSTM</p><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p>LSTM 的出现是因为如果接受的序列过长RNN会出现梯度消失和梯度爆炸的问题，所以我们应该有办法来限制历史信息不应该太长。</p><p>于是有了LSTM， 实际上就是一个进化一点的RNN啦</p><p>变化在于这里:</p><ol><li>多了一个传递信息C来控制哪些信息是需要的哪些信息是不需要的</li><li>将原本的out拆成了四份</li></ol><p>来看具体的，先上一张图:<br><img src="https://pic2.zhimg.com/v2-556c74f0e025a47fea05dc0f76ea775d_1200x500.jpg" srcset="/img/loading.gif" alt="人人都能看懂的LSTM" style="zoom:50%;" /></p><p>其实上图已经说得很明白了哈哈哈哈</p><p>我们输入的依旧是N x T x D 的 x ， 这里我们会将x乘以W矩阵(D x 4H) 就会得到NxTx4H 的 out(同理对于历史信息)，</p><p>注意，这里的拆分之前是跟RNN一致的，先求出out</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204045946993.png" srcset="/img/loading.gif" alt="image-20200204045946993"></p><p>out就可以进行拆分成上图的 i, f , o, g (计算过程字母参照公式不是图)</p><p>拆分之后的计算()：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204045930064.png" srcset="/img/loading.gif" alt="image-20200204045930064"></p><p>之后算出传递信息</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204045938044.png" srcset="/img/loading.gif" alt="image-20200204045938044"></p><p>然后说一下LSTM的backward：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204051653566.png" srcset="/img/loading.gif" alt="image-20200204051653566"></p><p>这里解释了怎么得到dout(有点潦草)，但有了dout之后，相当于就把他拼回去了，之后就跟正常的一样求需要的就可以了</p><h3 id="留了个问题"><a href="#留了个问题" class="headerlink" title="留了个问题"></a>留了个问题</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200204051843512.png" srcset="/img/loading.gif" alt="image-20200204051843512"></p><p>没太理解这一部分内容，由于连不上远程主机也看到具体效果</p>]]></content>
    
    
    <categories>
      
      <category>Deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CNN</title>
    <link href="/2019/11/13/CNN/"/>
    <url>/2019/11/13/CNN/</url>
    
    <content type="html"><![CDATA[<h1 id="CNN总结"><a href="#CNN总结" class="headerlink" title="CNN总结"></a>CNN总结</h1><p>​    老样子，我们按照做的顺序来介绍</p><h3 id="卷积的前向传播"><a href="#卷积的前向传播" class="headerlink" title="卷积的前向传播"></a>卷积的前向传播</h3><p>​    一般输入是X(N, C, H, W)也就是说N个样本， C个channel，样本大小是H x W </p><p>​    卷积就是我们之前提到的</p><p><img src="https://mlnotebook.github.io/img/CNN/convSobel.gif" srcset="/img/loading.gif" alt="img"></p><p>​    图中这里只展示了单通道的卷积，在实际中是多通道的，直观理解就是立方体乘以立方体了</p><p>​    但是我们也是可以看到，经过卷积之后发现是变小了的，但最本质的原因还是在于边界处的像素点相对于中心部分是被少计算了的</p><p>​    于是我们有了padding，至于padding的大小，这个也可以很直观的看出来：</p><p>​    H_padding = (filter_size - 1) // 2</p><p>​    w_padding = (filter_size - 1) // 2</p><p>​    从这里也可看出，filter_size的大小绝大多都是奇数乘以奇数。一是因为这个原因，二是因为奇数容易确定中心</p><p>​    基本实现过程：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201103541987.png" srcset="/img/loading.gif" alt="image-20200201103541987"></p><p>​    之后就是卷积之后一个ReLu激活，这就是之前做过的，直接激活即可，只是之后BP的时候记得ReLU回来就可以了</p><h3 id="卷积的后向传播"><a href="#卷积的后向传播" class="headerlink" title="卷积的后向传播"></a>卷积的后向传播</h3><p>​    这个地方是相对比较复杂的部分，但是基本原理还是求梯度了</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200201104347702.png" srcset="/img/loading.gif" alt="image-20200201104347702"></p><p>​    直接从代码来看</p><p>​    首先拿出x那个之前被卷积的那一部分,</p><p>​    我们先不从量化数学的角度去想，直观的看， 可以看到dx的对应之前被卷积的部分是被加上了一坨东西的。 这坨东西是从后面传过来的导数然后乘以w然后一个个分到了x上，仔细一想这不就是之前我们多到1(卷积)，现在1到多回来了么。相当于每个x对这个导数做了多大贡献，之后根据贡献程度(w)摊到了x上。</p><p>就有点像：<br>$$<br>\dot{X_i} : f(\sum_i^nX_i<em>W_i))=&gt; df</em>\sum_i^nW_i<br>$$</p><p>​    哦对了，这里还有一个关于卷积后向讲得比较清楚的帖子，但是他这里需要将输入进行一个小小的变换，但是之后求解梯度的方法就具有很好的可解释性了。也是很好理解的方法！</p><p><a href="https://zhuanlan.zhihu.com/p/40951745" target="_blank" rel="noopener">传送门</a></p><h3 id="池化前向传播"><a href="#池化前向传播" class="headerlink" title="池化前向传播"></a>池化前向传播</h3><p>池化的话还算比较简单的啦，这里没有padding，毕竟这里就是想减小输入的大小</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201105635711.png" srcset="/img/loading.gif" alt="image-20200201105635711"></p><h3 id="池化后向传播"><a href="#池化后向传播" class="headerlink" title="池化后向传播"></a>池化后向传播</h3><p>跟卷积的后向传播一样</p><p>这里是最大池化，选出最大的，我们可以按照之前卷积给出的那个公式来理解，最大的那个点的Wi是1，其他的点Wi是0，这样一来求导数回来只需要返回到那个唯一对这个loss做贡献的点上去就可以了，如果是平均池化，则就是平摊这个导数了，平均池化还更简单些</p><p>实现上注意怎么求出这个mask使得导数全部回到那个最大的值上去就可以了，不过还好numpy给出了很便捷的方法，求解方法如下：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201110552824.png" srcset="/img/loading.gif" alt="image-20200201110552824"></p><p>解决了上述最为关键的几步之后，之后来看看高一层次的东西</p><p>在这里提一嘴，这几层的实现可以使用Cython进行加速</p><h3 id="三明治层"><a href="#三明治层" class="headerlink" title="三明治层"></a>三明治层</h3><p><img src="https://pic3.zhimg.com/80/v2-141ed65cf0003c9550a8d57fe7c6afb2_hd.png" srcset="/img/loading.gif" alt="img"></p><p>就是传说中的Con-&gt;ReLU-&gt;Pooling了哈哈哈</p><p>out, cache = conv_relu_forward(x, w, b, conv_param)</p><h3 id="三层卷积网络"><a href="#三层卷积网络" class="headerlink" title="三层卷积网络"></a>三层卷积网络</h3><p>这个就比较简单辣，直接把之前的拼起来就行，（卷积-池化）x N + 全连接层 = 卷积神经网络</p><p>全连接层就是我们之前很早就做过的affine_relu_forward 和affine_forward的组合了</p><p>一般都是affine_relu_forward x N + affine_forward = 全连接层</p><p>实现：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201111934487.png" srcset="/img/loading.gif" alt="image-20200201111934487"></p><p>可视化filter</p><p><img src="data:image/png;base64,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" srcset="/img/loading.gif" alt="img"></p><p>好了，基本的介绍完了，我们来看看可以用来优化的方法</p><p>由于没有单独做batch normalization，这里介绍一下normalization的方法</p><h3 id="Batch-normalization"><a href="#Batch-normalization" class="headerlink" title="Batch normalization"></a>Batch normalization</h3><h4 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h4><p>就是做一个标准化，这边使用了mu和sigema</p><p>具体公式如下</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201114630657.png" srcset="/img/loading.gif" alt="image-20200201114630657"><br>$$<br>X_I = \frac{X_i - \mu}{\sigma}<br>$$<br><img src="https://img-blog.csdn.net/20180326183535928" srcset="/img/loading.gif" alt="img"></p><p>注意这里的Xi是上面的XI</p><h4 id="Backward"><a href="#Backward" class="headerlink" title="Backward"></a>Backward</h4><p>​    backward就是高中求导了，首先传进来的是对XI的导数，之后我们对着Xi一顿操作求出对他的导数和传进来的导数乘起来就可以了。</p><p>​    具体的求导过程这里就不给出了。</p><p>​    具体实现如下：<br>​    <img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201115233470.png" srcset="/img/loading.gif" alt="image-20200201115233470"></p><p>注意，对于那个beta和gamma也是要有导数滴</p><h4 id="Spatial-batch-normalization"><a href="#Spatial-batch-normalization" class="headerlink" title="Spatial batch normalization"></a>Spatial batch normalization</h4><p>​    这个优化的思想还是比较容易懂的，因为我们是在batch方向做的normalization，但是仔细想想这是不合理的，因为我们的filter是channel方向做的map，所以我们根据channel方向来做normalization是更合理的，要实现这个，只需要将数据按照channel进行排开就可以了，实现如下</p><p>​    <img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201113414029.png" srcset="/img/loading.gif" alt="image-20200201113414029"></p><p>backward是一样的，转一下维度就可以了</p><h4 id="Group-normalization"><a href="#Group-normalization" class="headerlink" title="Group normalization"></a>Group normalization</h4><p><img src="https://img-blog.csdn.net/20180326183603614" srcset="/img/loading.gif" alt="img"></p><p>​    这里其实是对之前的一个进化，相当于是将数据按照channel排列之后再进行分组，然后在组内进行normalization，这么做的好处是训练时的每组数量固定，方差均值稳定</p><p>实现如下：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200201115815880.png" srcset="/img/loading.gif" alt="image-20200201115815880"></p><p>可以看到，除了分了组以外没啥区别，BP也是类似就不给出了</p>]]></content>
    
    
    <categories>
      
      <category>Deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Backward propagation</title>
    <link href="/2019/11/11/BP/"/>
    <url>/2019/11/11/BP/</url>
    
    <content type="html"><![CDATA[<h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>主要就是利用链式求导</p><p>反向传播分为两种:</p><ol><li>隐含层到输出层</li><li>隐含层到隐含层</li></ol><h3 id="隐含层到输出层"><a href="#隐含层到输出层" class="headerlink" title="隐含层到输出层"></a>隐含层到输出层</h3><p><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630142019140-402363317.png" srcset="/img/loading.gif" alt="img"></p><p>首先计算损失函数</p><p><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630151201812-1014280864.png" srcset="/img/loading.gif" alt="img"></p><p>为了得到某个权重对于总误差的影响:</p><p>得到：</p><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630151916796-1001638091.png" srcset="/img/loading.gif" alt="img" style="zoom:50%;" /><p>这样可以看到，就是一个反向回传的过程</p><p>​    <img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630152258437-1960839452.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630152511937-1667481051.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630152658109-214239362.png" srcset="/img/loading.gif" alt="img"></p><p>三者连乘<img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630152811640-888140287.png" srcset="/img/loading.gif" alt="img"></p><p>得到这个梯度之后进行更新权重即可</p><h3 id="隐含层到隐含层"><a href="#隐含层到隐含层" class="headerlink" title="隐含层到隐含层"></a>隐含层到隐含层</h3><p><img src="https://images2015.cnblogs.com/blog/853467/201606/853467-20160630154317562-311369571.png" srcset="/img/loading.gif" alt="img"></p><p>就是注意一个问题</p><p>因为隐含层到输出层是多对一，也就是说最后隐含层的节点只对后面一层的一个节点产生影响，当然回传也就是只需这个被影响的节点传回来，但是隐含层到隐含层是多对多，这也就是说前一个节点影响到了后一个的多个节点，所以和隐含层到输出层的不同就在于在计算回传的时候注意被影响的节点都要考虑到，仅此区别</p><p>如上图</p><p>​    <img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200116121839301.png" srcset="/img/loading.gif" alt="image-20200116121839301"></p><p>这个net就是权重矩阵，用于处理各个输入之间的关系</p><p>注意一下，所有更新权重，最后落到的都是损失函数对权重的求导</p>]]></content>
    
    
    <categories>
      
      <category>Deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mess</title>
    <link href="/2019/11/02/mess/"/>
    <url>/2019/11/02/mess/</url>
    
    <content type="html"><![CDATA[<h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><p>对目前CNN知识的一点小总结，前前后后学了CNN几遍了，看了忘，忘了看，希望这次做个试验把他记住咯。</p><p>按顺序CNN的顺序进行一个知识点总结吧</p><p>基本顺序:</p><p>输入图片-&gt;卷积-&gt;池化-&gt;MLP-&gt;输出</p><p>从卷积说起</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>这个还是比较简单的，注意下卷积核的概念就好</p><p><img src="https://mlnotebook.github.io/img/CNN/convSobel.gif" srcset="/img/loading.gif" alt="img">)<img src="https://pic1.zhimg.com/v2-fb26f8eeaea46279cf9e94695289b44c_r.jpg" srcset="/img/loading.gif" alt="preview"></p><p>目前照我的理解，卷积层中会有多个卷积核，得到多种feature map, 如下图所示</p><h3 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h3><p>卷积之后进行一个类似于激活的操作，对卷积出来的结果进行一个激活</p><p>卷积层对原图运算多个卷积产生一组线性激活响应，而非线性激活层是对之前的结果进行一个非线性的激活响应。</p><p>在神经网络中用到最多的非线性激活函数是Relu函数，它的公式定义如下：</p><p>f(x)=max(0,x)</p><p>即，保留大于等于0的值，其余所有小于0的数值直接改写为0。</p><p>为什么要这么做呢？上面说到，卷积后产生的特征图中的值，越靠近1表示与该特征越关联，越靠近-1表示越不关联，而我们进行特征提取时，为了使得数据更少，操作更方便，就直接舍弃掉那些不相关联的数据。</p><p><img src="https://pic4.zhimg.com/80/v2-b9508442abbab0395810df7f288ceda7_hd.png" srcset="/img/loading.gif" alt="img"></p><h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p><img src="https://pic3.zhimg.com/80/v2-bc7736e0a815c8db07a855c35234b76e_hd.png" srcset="/img/loading.gif" alt="img"></p><p>之后便是重复这个过程到某一程度</p><h3 id="全连接层-MLP"><a href="#全连接层-MLP" class="headerlink" title="全连接层(MLP)"></a>全连接层(MLP)</h3><p>在这之后，便是CNN的最后一部分，全连接层，而这一部分就和我们之前学到的MLP是一致的了</p><p>输入是就是池化过的一些向量了</p><p>接着就是我们熟悉的<strong>XW=Y</strong>环节了</p><p>最后使用softmax函数输出最可能class即可</p><p><img src="https://pic3.zhimg.com/80/v2-141ed65cf0003c9550a8d57fe7c6afb2_hd.png" srcset="/img/loading.gif" alt="img"></p><p>这个地方要涉及到几个知识点，对于输入的数据进行处理:</p><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><p>降维在之前也是提到过的，就是比如投影或者换句话说PCA(主成分分析)</p><h5 id="白化"><a href="#白化" class="headerlink" title="白化"></a>白化</h5><p>白化分为PCA白化与ZCA白化，这里简单说一下PCA白化</p><p>先看一下PCA处理，至于特征值是通过奇异值分解得出的</p><p><img src="https://img-blog.csdn.net/20160312120205309" srcset="/img/loading.gif" alt="img"></p><p><img src="https://img-blog.csdn.net/20160312120214088" srcset="/img/loading.gif" alt="img"></p><p>现在要提到一点，虽然PCA使得数据可以降维，但是为了做到数据标准化，我们还需要白化，首先解释一下什么是数据标准化以及他的意义</p><h5 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h5><p>机器学习中, 如果我们以一个简单的线性回归方程来预测房屋的价格, 那方程可能会是这样 . </p><p>价格= a* 离市中心 + b * 楼层 + c * 面积. 其中的 a b c 就是机器学习需要努力努力再努力 来优化的参数.</p><p><img src="https://morvanzhou.github.io/static/results/ML-intro/norm5.png" srcset="/img/loading.gif" alt="特征标准化 (Feature Normalization)"></p><p>我们可以把 abc 想想成3个人. 他们共同努力解决一个问题, 在某一个问题中, a工作的时候总是不知道发生了什么, b 的能力适中, c 工作能力最强, 老板看了他们一起工作的结果, 发现还有很多可以提高的地方, 然后不屑地说: 你们这个结果和我期望的还有很大差距, 你们快去缩小差距. 老板给的要求只是缩小差距. 可是 abc 都不知道差距在哪. 所以他们这次只好平分接下来的任务, 不过 c 很快就做完了, b 第二, a 做得很慢, 所以花的总时间很长, c 和 b 都要等 a 把剩下的工作做完才能再给老板看结果, 这样 效率并不高.</p><p>​    把这个问题放在机器学习中, 为了好理解, 我们把 b 先排除掉. 再把房价问题也简化一下, 留下两个特征. 因为面积的跨度一般可以从0 到 2-300, 而离市中心的距离跨度一般在10以内. 所以在这个公式中, c 只要稍稍变化一点, 他乘以面积的变化就会很大, 因为面积的值可以很大, 但是当a也变化那一点点时, 他对预测价格的影响力不会像 c 那样巨大. 这样的差别就会影响最终的工作效率. 所以, 我们要提高效率, 特征的标准化就可以帮上忙. 我们在机器学习训练之前, 先对数据预先处理一下, 取值跨度大的特征数据, 我们浓缩一下, 跨度小的括展一下, 使他们的跨度尽量统一.</p><p><a href="https://morvanzhou.github.io/static/results/ML-intro/norm6.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/ML-intro/norm6.png" srcset="/img/loading.gif" alt="特征标准化 (Feature Normalization)"></a></p><p>这就是数据标准化的意义，接下来便是具体的数据化标准: PCA白化</p><h5 id="PCA白化"><a href="#PCA白化" class="headerlink" title="PCA白化"></a>PCA白化</h5><p>所谓的pca白化是指对上面的pca的新坐标X’,每一维的特征做一个标准差归一化处理。因为从上面我们看到在新的坐标空间中，(x1,x2)两个坐标轴方向的数据明显标准差不同，因此我们接着要对新的每一维坐标做一个标注差归一化处理：</p><p><img src="https://img-blog.csdn.net/20160312121312585" srcset="/img/loading.gif" alt="img"></p><p>当然你也可以采用下面的公式：</p><p><img src="https://img-blog.csdn.net/20160312121413148" srcset="/img/loading.gif" alt="img"></p><p>得到效果</p><p><img src="https://img-blog.csdn.net/20160312121102984" srcset="/img/loading.gif" alt="img"></p><p>而ZCA白化则是将修改过的数据还原到最开始的坐标下去</p><p>在有了之前的特征标准化之后，再说一下批标准化</p><h5 id="批标准化"><a href="#批标准化" class="headerlink" title="批标准化"></a>批标准化</h5><p>批标准化在我看来主要是在做这样一件事情:</p><p>在输出的时候，在激活函数和network层之间加一个BN层，相当于是把<strong>WX</strong>这个结果标准化到了激活函数敏感的区间中去，举个栗子    </p><p><img src="https://morvanzhou.github.io/static/results/ML-intro/NB5.png" srcset="/img/loading.gif" alt="批标准化 (Batch Normalization)"></p><p>当数据分布在两侧过多的时候，事实上激活函数对数据就不敏感了。</p><p>所以在标准化之后就会好很多。</p><p><img src="https://morvanzhou.github.io/static/results/ML-intro/NB4.png" srcset="/img/loading.gif" alt="批标准化 (Batch Normalization)"></p><p>之后就是训练内容</p><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>训练的话在全连接层是我们学过的BP算法即可</p><p><strong>池化层</strong></p><p><strong>卷积层</strong></p><p>这两者有其特殊的方法更新矩阵</p>]]></content>
    
    
    <categories>
      
      <category>Deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Deep learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Softmax</title>
    <link href="/2019/10/26/softmax/"/>
    <url>/2019/10/26/softmax/</url>
    
    <content type="html"><![CDATA[<h1 id="SoftMax"><a href="#SoftMax" class="headerlink" title="SoftMax"></a>SoftMax</h1><p>首先介绍一下softmax公式</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200123113540949.png" srcset="/img/loading.gif" alt="image-20200123113540949"></p><p>当然损失函数也是比较好理解的</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200123113606800.png" srcset="/img/loading.gif" alt="image-20200123113606800"></p><p><img src="https://img-blog.csdnimg.cn/20190119172501716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDcyNzgwNTUx,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"></p><p>求梯度</p><p><img src="https://gitee.com/xxuffei/picture_set/raw/master/0508s1.jpg" srcset="/img/loading.gif" alt="0508s1"></p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200123120100283.png" srcset="/img/loading.gif" alt="image-20200123120100283"></p><p><em>o</em>1,<em>o</em>2,<em>o</em>3代表是结点1,2,3往后传的输入.</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200123120043275.png" srcset="/img/loading.gif" alt="image-20200123120043275"></p><h3 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h3><ol><li><p>首先实验的时候就可以从另外一个角度去理解这个loss</p><p>loss这样理解：正确种类的标准化得分的比例取对数再取反，因为要将这个分数最大化嘛，也就是将这个loss最小化即可。</p></li><li><p>换一个角度去理解这个梯度的更新：错误的分类按照标准化分数之后的比例来取Xi定对应的Wi，就比如，Xi被在类K的得分为Ck，然后有关系Xi@Wi = Ck, 这时更新dW，dW = dW + Xi*p</p><p>这个p是在k这个错误分类的得分标准化之后所占的比例，至于为什么是乘以Xi，因为Xi可以理解为一组feature，这个feature被错误分类了，所以需要减少对应的Wi， 所以dW是加（之后的更新是按照反方向进行的）。而对于正确类的W，这是加上对应的Xi，注意这里不乘以比例</p></li><li><p><strong>注意点</strong>：</p><ol><li>score得出之后一定要减去这一组的最大值，防止在取对数之后爆炸</li><li>记得W = W - <strong>leaning_rate*</strong>dW 学习率往往是比较小的，这个一定要记得乘上去，要不然也会炸掉的！</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PKI</title>
    <link href="/2019/10/20/PKI/"/>
    <url>/2019/10/20/PKI/</url>
    
    <content type="html"><![CDATA[<h1 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h1><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>证书签发机构（CA）<br>证书注册机构（RA）<br>证书库<br>密钥备份及恢复系统(签名私钥是不在PKI备份的！)<br>证书废除处理系统<br>应用系统接口</p><h3 id="证书签发机构CA"><a href="#证书签发机构CA" class="headerlink" title="证书签发机构CA"></a>证书签发机构CA</h3><p>CA对任何一个主体的公钥进行公证<br>CA通过签发证书将主体与公钥进行捆绑</p><h4 id="证书注册机构RA"><a href="#证书注册机构RA" class="headerlink" title="证书注册机构RA"></a>证书注册机构RA</h4><p>RA（Registration Authority)是CA的组成部分，RA是CA面向用户的窗口，它负责接收用户的证书申请，审核用户的身份，RA也负责向用户发放证书</p><h4 id="密钥备份与恢复"><a href="#密钥备份与恢复" class="headerlink" title="密钥备份与恢复"></a>密钥备份与恢复</h4><p>根据用户的需求，CA中心可以对用户的加密私钥进行备份，并确保密钥安全所有密钥的备份都采用密钥分享技术，并将备份信息分段保存在不同地方。所有密钥的恢复必须满足一定条件（人数、信息分段的位置、特定的算法）才能完成。</p><h4 id="PKI的标准化"><a href="#PKI的标准化" class="headerlink" title="PKI的标准化"></a>PKI的标准化</h4><p>标准化可以实现规定的安全水平，具有兼容性，在保障安全的互连互通中起到关键作用<br>标准化有利于降低成本、训练操作人员和技术的推广使用<br>ITU-T X.509<br>PKIX文档（RFC）<br>PKCS系列标准</p><h4 id="一般结构"><a href="#一般结构" class="headerlink" title="一般结构"></a>一般结构</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200102173057649.png" srcset="/img/loading.gif" alt="image-20200102173057649"></p><h3 id="PKI的关键技术"><a href="#PKI的关键技术" class="headerlink" title="PKI的关键技术"></a>PKI的关键技术</h3><p>数字证书<br>证书认证中心<br>证书撤销机制<br>PKI信任模型</p><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>证明用户身份，由机构向用户颁发的。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200102173514436.png" srcset="/img/loading.gif" alt="image-20200102173514436"></p><h4 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h4><h5 id="颁发证书的过程"><a href="#颁发证书的过程" class="headerlink" title="颁发证书的过程:"></a>颁发证书的过程:</h5><ol><li><p>用户到认证中心（CA）的业务受理点申请证书</p></li><li><p>认证中心审核用户的身份</p></li><li><p>认证中心为审核通过的用户签发证书</p></li><li><p>认证中心将证书灌制到证书介质中，发放给用户</p></li></ol><h4 id="废除证书"><a href="#废除证书" class="headerlink" title="废除证书"></a>废除证书</h4><h5 id="废除证书的原因"><a href="#废除证书的原因" class="headerlink" title="废除证书的原因"></a>废除证书的原因</h5><ol><li>证书用户身份信息的变更</li><li>CA签名私钥的泄漏</li><li>证书对应私钥的泄漏</li><li>证书本身遭到损坏</li><li>其他原因</li></ol><h5 id="证书废除过程"><a href="#证书废除过程" class="headerlink" title="证书废除过程"></a>证书废除过程</h5><ol><li>用户到认证中心的业务受理点申请废除证书</li><li>认证中心审核用户的身份</li><li>认证中心定期签发证书黑名单（CRL）</li><li>认证中心将更新的CRL在线发布，供用户查询和下载<ol><li>CRL:   CRL是由CA认证中心定期发布的具有一定格式的数据文件，它包含了所有未到期的已被废除的证书信息。</li></ol></li></ol><h4 id="交叉认证"><a href="#交叉认证" class="headerlink" title="交叉认证"></a>交叉认证</h4><p>建立一个单一全球性的PKI是不太可能实现的，一段时间内，会存在多个PKI域，进行独立的运行和操作。<br>由于业务关系的改变或其他一些原因，不同的PKI的用户团体之间必须进行安全通信。<br>在以前没有联系的PKI之间建立信任关系，就需要实现交叉认证。<br>它能够让一个PKI团体的用户验证另一个PKI团体的用户证书，从而实现安全通信。</p><h5 id="域内交叉认证"><a href="#域内交叉认证" class="headerlink" title="域内交叉认证"></a>域内交叉认证</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200102174511458.png" srcset="/img/loading.gif" alt="image-20200102174511458"></p><h5 id="域间交叉认证"><a href="#域间交叉认证" class="headerlink" title="域间交叉认证"></a>域间交叉认证</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200102174519134.png" srcset="/img/loading.gif" alt="image-20200102174519134"></p><h5 id="正向交叉认证"><a href="#正向交叉认证" class="headerlink" title="正向交叉认证"></a>正向交叉认证</h5><h5 id="反向交叉认证"><a href="#反向交叉认证" class="headerlink" title="反向交叉认证"></a>反向交叉认证</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200102175005462.png" srcset="/img/loading.gif" alt="image-20200102175005462"></p><h5 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200102175055091.png" srcset="/img/loading.gif" alt="image-20200102175055091"></p><h5 id="验证证书"><a href="#验证证书" class="headerlink" title="验证证书"></a>验证证书</h5><p>为了获得对某一证书的信任，验证者必须验证关于每一个证书的三个方面，直到到达一个可信的根。</p><p>STEP1: 验证真实性。证书是否为可信任的CA认证中心签发？（基于证书链进行验证）</p><p>STEP2:验证有效性。证书是否在证书的有效使用期之内？</p><p>STEP3:验证可用性。证书是否已废除？（证书可用性的验证是通过证书撤销机制来实现的。）</p>]]></content>
    
    
    <categories>
      
      <category>Cryptography</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cryptography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerberos</title>
    <link href="/2019/10/13/Kerberos%E5%8D%8F%E8%AE%AE/"/>
    <url>/2019/10/13/Kerberos%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h1><p>算法、协议、密码协议<br><strong>算法(Algorithm)</strong>：一系列步骤，完成一项任务。<br><strong>协议(Protocol)</strong>：一系列步骤，它包括两方或多方，设计它的目的是<br>要完成一项任务。<br>– 协议中的每个人都必须了解协议，并且预先知道所要完成的步骤；<br>– 协议中的每个人都必须同意并遵循它；<br>– 协议必须是清楚的，每一步必须明确定义，并且不会引起误解；<br>– 协议必须是完整的，对每种可能的情况必须规定具体的动作；</p><p><strong>密码协议(Cryptographic Protocol)</strong>：是使用密码学的协议<br>– 参与该协议的伙伴可能是朋友和完全信任的人，或者也可能是敌人和互相完全不信任的人。<br>– 包含某种密码算法，但通常协议的目的不仅仅是为了简单的秘密性；<br>– 参与协议的各方可能为了计算一个数值想共享他们的秘密部分、共同产生随机系列，确定互相的身份或者同时签署合同。<br>– 使用密码的目的是防止或发现窃听者和欺骗。</p><h4 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h4><h5 id="仲裁协议"><a href="#仲裁协议" class="headerlink" title="仲裁协议"></a>仲裁协议</h5><p>仲裁者是在完成协议的过程中，值得信任的公正的第三方</p><p><strong>EXAMPLE:</strong></p><ol><li>Alice 要卖车给不认识的Bob，Bob想用支票付帐，但Alice不知道支票的真假。同样，Bob也不相信Alice，在没有获得所有权前，不愿意将支票交与Alice. </li><li>Alice将车的所有权交给律师</li><li>Bob将支票交给Alice</li><li>Alice在银行兑现支票 在支票兑现无误后，律师将车的所有权交给Bob，若在规定的时间内支票不能兑现，Alice将出示证据给律师，律师将车的所有权和钥匙交还给Alice</li></ol><p><strong>裁决协议</strong></p><p>裁决协议协议包括两个低级的子协议：</p><ol><li>一个是非仲裁子协议，执行协议的各方每次想要完成的，</li><li>另一个是裁决子协议，仅在例外的情况下，即有争议的时候才执行，这种特殊的仲裁者叫裁决人，法官</li></ol><p><strong>EXAMPLE:</strong></p><p>非仲裁子协议<br>① A和B谈判合同的条款<br>② A签署合同<br>③ B签署合同<br>裁决子协议（仅在有争议时执行）：<br>① A和B出现在法官面前<br>② A提出她的证据<br>③ B也提出她的证据<br>④ 法官根据证据裁决</p><h5 id="自动执行协议"><a href="#自动执行协议" class="headerlink" title="自动执行协议"></a>自动执行协议</h5><p>协议本身就保证了公平性，不需要仲裁者来完成协议，也不需要裁决者来解决争端。</p><h3 id="Kerberos协议-1"><a href="#Kerberos协议-1" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h3><p>Kerceros协议实际上实现的是服务器和用户的双向认证问题，并且保证安全和时效性</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200101181705589.png" srcset="/img/loading.gif" alt="image-20200101181705589"></p><p>这个看电影的有三个问题:</p><ol><li>多次出示信用卡，容易被窃听</li><li>这个票是有时效性的</li><li>多个电影院看电影是否可迁移？</li></ol><p>于是有了Kerberos:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200101181459702.png" srcset="/img/loading.gif" alt="image-20200101181459702"></p><ol><li>将售票处一分为二，一个专门发许可证，一个发票子<ul><li>许可证部门:AS</li><li>票据发放: TGS服务器</li></ul></li><li>在票上加入时间戳</li></ol><p>实现细节:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200101182140978.png" srcset="/img/loading.gif" alt="image-20200101182140978"></p><p>用户与AS共享密钥Kc，AS与TGS共享Ktgs</p><p>TGS与服务器V共享密钥Kv</p><ol><li>用户向AS提供自己的信息，验证通过则使用共享密钥Kc,发送许可证，和一个TGS与客户端通信的会话密钥(因为AS与TGS并无共享，所以要在使用的时候通过AS来分发一个会话密钥)并附上有效期</li><li>用户解开，得到许可证</li><li>用户向TGS发送用Kc，tgs加密的许可证</li><li>TGS收到之后，返回用Kc,tgs加密的带时间戳的票子和一个用户与服务器通信的会话密钥Kc，v(理由同上)</li><li>用户向服务器发送票据，服务器解开，此时便实现了服务器对用户的认证</li></ol><p>但是，用户还没妹有对服务器认证呢</p><p>于是:</p><ol start="6"><li>服务器用kc，v加密一个带时间戳的消息，若用户解开有意义，则说明服务器么问题</li></ol>]]></content>
    
    
    <categories>
      
      <category>Cryptography</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Cryptography</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ActiveX 控件的利用，挖掘与防治</title>
    <link href="/2019/10/10/ActiveX%20%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%EF%BC%8C%E6%8C%96%E6%8E%98%E4%B8%8E%E9%98%B2%E6%B2%BB/"/>
    <url>/2019/10/10/ActiveX%20%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%88%A9%E7%94%A8%EF%BC%8C%E6%8C%96%E6%8E%98%E4%B8%8E%E9%98%B2%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="ActiveX-控件的利用，挖掘与防治"><a href="#ActiveX-控件的利用，挖掘与防治" class="headerlink" title="ActiveX 控件的利用，挖掘与防治"></a>ActiveX 控件的利用，挖掘与防治</h1><h4 id="什么是ActiveX？"><a href="#什么是ActiveX？" class="headerlink" title="什么是ActiveX？"></a>什么是ActiveX？</h4><p>​    ActiveX是Microsoft对于一系列策略性面向对象程序技术和工具的称呼，其中主要的技术是组件对象模型(COM)。在有目录和其它支持的网络中，COM变成了分布式COM（DCOM）。    </p><p>​    通过一个精心构造的页面 exploit 第三方软件中的 ActiveX 已经成为“网马”惯用的手段。近年来，众多知名软件公司都曾被发现其注册的 ActiveX 中存在严重的缓冲区溢出漏洞，并且能够允许攻击者执行任意代码。一个被广泛使用的第三方应用软件，其出现安全漏洞后的危害性不亚于操作系统级别的安全漏洞</p><h3 id="如何利用ActiveX？"><a href="#如何利用ActiveX？" class="headerlink" title="如何利用ActiveX？"></a>如何利用ActiveX？</h3><p>这里给出一个简单的栗子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">classid</span>=<span class="string">"clsid: 00000000-0000-0000-0000-000000000000"</span> <span class="attr">name</span>=<span class="string">"evil"</span> &gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="actionscript">evil.Vulfunc(<span class="string">""</span>)；</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    代码“object”这一行用来完成对被测试 ActiveX 控件进行调用的工作。在实际测试某一个 ActiveX 控件的时候，需要修改该行中“clsid”后的具体数值，也就是“00000000-0000- 0000-0000-000000000000”这里。</p><p>​    Clsid 的值可以从注册表“HKEY_CLASSES _ROOT\CLSID”中获得也可以用稍后介绍的工具获得。“script”部分是具体的测试代码。由于“object”部分调用了 ActiveX 控件，并且建立了“name”标签，用一个内存对象“evil”来代表该 ActiveX 控件。</p><p>​    所以，在“script”部分只需要调用“evil”这个对象就可以替代 ActiveX 控件本身。接下来可以通过 evil 对象逐一调用控件内的所有方法，并传入各类畸形的参数，观察控件的反应。例如，这里我们测试了“Vulfunc(“”)”这个方法</p><p>​    <strong>这也就意味着调用了注册的方法，而对于注册的方法的利用我们很容易就会想到很多关于软件安全的知识，栈溢出，堆溢出等等。</strong>但是由于这些被调用的方法多种多样，所以在利用之前我们需要进行exploit！</p><h3 id="如何exploit？当然是fuzz！"><a href="#如何exploit？当然是fuzz！" class="headerlink" title="如何exploit？当然是fuzz！"></a>如何exploit？当然是fuzz！</h3><p>这里给出几个有名fuzz ActiveX的工具：</p><ol><li><p>COMRaider：(<a href="http://labs.idefense.com/software/fuzzing.php#more_comraider)，著名的iDefense" target="_blank" rel="noopener">http://labs.idefense.com/software/fuzzing.php#more_comraider)，著名的iDefense</a> LAB 出品，其作者是 David Zimmer。一款非常出色的 ActiveX Fuzz 工具，并且可以免费使用。</p></li><li><p>AxMan ：(<a href="http://metasploit.com/users/hdm/tools/axman/" target="_blank" rel="noopener">http://metasploit.com/users/hdm/tools/axman/</a>) ，基于 IE 的 ActiveX Fu zz 工具，必须配合 IE 一起使用，目前只支持 IE 6.0。 </p></li><li><p>Axfuzz ：(<a href="http://sourceforge.net/projects/axfuzz)，一个开源的工具，可以列举" target="_blank" rel="noopener">http://sourceforge.net/projects/axfuzz)，一个开源的工具，可以列举</a> COM 的所有属性，并进行简单的 Fuzz。您可以通过阅读这个工具的源码学习怎样编写自己的 ActiveX。</p></li></ol><p>这里简单看一下COMRaider</p><p>就像所有fuzz的原理一样，COMRaider先生成具有代表性的输入模板，如下图</p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302012413530.png" srcset="/img/loading.gif" alt="image-20200302012413530" style="zoom: 67%;" /><p>之后挨个测试模板和输出，查看报错，下图可以看到对错误的记录</p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302012501095.png" srcset="/img/loading.gif" alt="image-20200302012501095" style="zoom:80%;" /><p>并且可以查看详细信息</p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200302012822185.png" srcset="/img/loading.gif" alt="image-20200302012822185" style="zoom:67%;" /><p>之后找到对应错误的fuzz模板，比如上面这个错误的模板是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?XML version='1.0' standalone='yes' ?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span><span class="tag">&lt;<span class="name">job</span> <span class="attr">id</span>=<span class="string">'DoneInVBS'</span> <span class="attr">debug</span>=<span class="string">'false'</span> <span class="attr">error</span>=<span class="string">'true'</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">classid</span>=<span class="string">'clsid:8EF2A07C-6E69-4144-96AA-2247D892A73D'</span> <span class="attr">id</span>=<span class="string">'target'</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">'vbscript'</span>&gt;</span> </span><br><span class="line">'File Generated by COMRaider v0.0.133 - http://labs.idefense.com </span><br><span class="line">'Wscript.echo typename(target) </span><br><span class="line">'for debugging/custom prolog </span><br><span class="line"><span class="actionscript">targetFile = <span class="string">"D:\iDefense\COMRaider\vuln.dll"</span> </span></span><br><span class="line"><span class="actionscript">prototype = <span class="string">"Function Method1 ( ByVal sPath As String ) As Long"</span> </span></span><br><span class="line"><span class="actionscript">memberName = <span class="string">"Method1"</span> </span></span><br><span class="line"><span class="actionscript">progid = <span class="string">"VULNLib.server"</span> </span></span><br><span class="line">argCount = 1 </span><br><span class="line"><span class="javascript">arg1=<span class="built_in">String</span>(<span class="number">9236</span>, <span class="string">"A"</span>) </span></span><br><span class="line">target.Method1 arg1 <span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">job</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    可以看到，其中的arg1=String(9236, “A”)，产生了一个超长字符串，很明显的栈溢出漏洞，就这样被发现了，之后便利用我们软件安全课上学到的知识，利用栈溢出进行攻击即可，具体的栈溢出攻击方法就不在这次讨论范围内了。</p><h3 id="如何防止ActiveX-网马的攻击"><a href="#如何防止ActiveX-网马的攻击" class="headerlink" title="如何防止ActiveX 网马的攻击"></a>如何防止ActiveX 网马的攻击</h3><p>​    准确的说，网页木马并不是木马程序，而应该称为网页木马“种植器”，也即一种通过攻击浏览器或浏览器外挂程序（目标通常是IE浏览器和ActiveX程序）的漏洞，向目标用户机器植入木马、病毒、密码盗取等恶意程序的手段。</p><p>目前来说一般对于这种利用ActiveX来进行攻击的木马，有这样几种方式</p><ol><li><p>安装并及时更新反病毒软件，用户可尽量选择网页木马查杀能力较强的反病毒软件，并及时更新病毒特征库，这样的话，即使网页木马使用了最新的加密技术躲过反病毒软件的检测，但较新的病毒特征库也能尽可能用户免受紧跟网页木马而来的恶意软件的损害。</p></li><li><p>使用第三方浏览器，由于目前互联网上常见的网页木马所使用的是针对IE浏览器及其ActiveX控件的漏洞，因此，使用Firefox/Opera等非IE内核的第三方浏览器可以从源头上堵住网页木马的攻击，不过第三方浏览器在页面兼容性上稍逊IE浏览器，而且一些特别的网页，如各种使用ActiveX密码登陆控件的网上银行不能使用第三方浏览器登陆，用户在浏览这类网页时可使用IE浏览器。</p></li><li><p>养成安全的网站浏览习惯，用户应该养成安全的网站浏览习惯，不要随便点击各种来源不明，说明带有引诱语言的链接，防止落入攻击者的陷阱；遇到合法网站被攻击者攻陷并挂上网页木马，用户也应该报告网站管理员。</p><p>虽然上面的一些方法可能是我们老生常谈的“安全习惯”，但是不得不承认，能做到以上几点就可以杜绝大部分的互联网恶意攻击</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transfer Learning</title>
    <link href="/2019/10/02/transferLearning/"/>
    <url>/2019/10/02/transferLearning/</url>
    
    <content type="html"><![CDATA[<h1 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h1><p>迁移学习概述<br>背景<br>随着越来越多的机器学习应用场景的出现，而现有表现比较好的监督学习需要大量的标注数据，标注数据是一项枯燥无味且花费巨大的任务，所以迁移学习受到越来越多的关注。</p><p>传统机器学习(主要指监督学习)</p><p><strong>基于同分布假设</strong><br>需要大量标注数据<br>然而实际使用过程中不同数据集可能存在一些问题，比如</p><p><strong>数据分布差异</strong></p><p><strong>标注数据过期</strong><br>训练数据过期，也就是好不容易标定的数据要被丢弃，有些应用中数据是分布随着时间推移会有变化</p><p>如何充分利用之前标注好的数据（废物利用），同时又保证在新的任务上的模型精度？<br>基于这样的问题，所以就有了对于迁移学习的研究</p><p><img src="https://img-blog.csdnimg.cn/20190106221921111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rha2Vueg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>定义及分类<br>Transfer Learning Definition:<br>Ability of a system to recognize and apply knowledge and skills learned in previous domains/tasks to novel domains/tasks.</p><p><strong>目标</strong><br>将某个领域或任务上学习到的知识或模式应用到不同但相关的领域或问题中。</p><p><strong>主要思想</strong><br>从相关领域中迁移标注数据或者知识结构、完成或改进目标领域或任务的学习效果。</p><p><img src="https://img-blog.csdnimg.cn/20190106223002518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rha2Vueg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>人在实际生活中有很多迁移学习，比如学会骑自行车，就比较容易学摩托车，学会了C语言，在学一些其它编程语言会简单很多。那么机器是否能够像人类一样举一反三呢？</p><p><img src="https://img-blog.csdnimg.cn/20190106223151869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rha2Vueg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>上图是一个商品评论情感分析的例子，图中包含两个不同的产品领域：books 图书领域和 furniture 家具领域；在图书领域，通常用“broad”、“quality fiction”等词汇来表达正面情感，而在家具领域中却由“sharp”、“light weight”等词汇来表达正面情感。可见此任务中，不同领域的不同情感词多数不发生重叠、存在领域独享词、且词汇在不同领域出现的频率显著不同，因此会导致领域间的概率分布失配问题。</p><p>迁移学习的形式定义及一种分类方式</p><p>迁移学习里有两个非常重要的概念</p><h3 id="域（Domain）"><a href="#域（Domain）" class="headerlink" title="域（Domain）"></a>域（Domain）</h3><h3 id="任务（Task）"><a href="#任务（Task）" class="headerlink" title="任务（Task）"></a>任务（Task）</h3><p>域 可以理解为某个时刻的某个特定领域，比如书本评论和电视剧评论可以看作是两个不同的domain<br>任务 就是要做的事情，比如情感分析和实体识别就是两个不同的task</p><p>关键点</p><p>研究可以用哪些知识在不同的领域或者任务中进行迁移学习，即不同领域之间有哪些共有知识可以迁移。<br>研究在找到了迁移对象之后，针对具体问题所采用哪种迁移学习的特定算法，即如何设计出合适的算法来提取和迁移共有知识。<br>研究什么情况下适合迁移，迁移技巧是否适合具体应用，其中涉及到负迁移的问题。<br>当领域间的概率分布差异很大时，上述假设通常难以成立，这会导致严重的负迁移问题。<br>负迁移是旧知识对新知识学习的阻碍作用，比如学习了三轮车之后对骑自行车的影响，和学习汉语拼音对学英文字母的影响<br>研究如何利用正迁移，避免负迁移</p><h3 id="基于实例的迁移"><a href="#基于实例的迁移" class="headerlink" title="基于实例的迁移"></a>基于实例的迁移</h3><p>基于实例的迁移学习研究的是，如何从源领域中挑选出，对目标领域的训练有用的实例，比如对源领域的有标记数据实例进行有效的权重分配，让源域实例分布接近目标域的实例分布，从而在目标领域中建立一个分类精度较高的、可靠地学习模型。<br>因为，迁移学习中源领域与目标领域的数据分布是不一致，所以源领域中所有有标记的数据实例不一定都对目标领域有用。戴文渊等人提出的TrAdaBoost算法就是典型的基于实例的迁移。</p><p><img src="https://img-blog.csdnimg.cn/20190106225855611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rha2Vueg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="基于特征的迁移"><a href="#基于特征的迁移" class="headerlink" title="基于特征的迁移"></a>基于特征的迁移</h3><p>特征选择<br>基于特征选择的迁移学习算法，关注的是如何找出源领域与目标领域之间共同的特征表示，然后利用这些特征进行知识迁移。</p><p><img src="https://img-blog.csdnimg.cn/20190106230435410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rha2Vueg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="特征映射"><a href="#特征映射" class="headerlink" title="特征映射"></a>特征映射</h4><p>基于特征映射的迁移学习算法，关注的是如何将源领域和目标领域的数据从原始特征空间映射到新的特征空间中去。<br>这样，在该空间中，源领域数据与的目标领域的数据分布相同，从而可以在新的空间中，更好地利用源领域已有的有标记数据样本进行分类训练，最终对目标领域的数据进行分类测试。</p><h3 id="基于共享参数的迁移"><a href="#基于共享参数的迁移" class="headerlink" title="基于共享参数的迁移"></a>基于共享参数的迁移</h3><p>基于共享参数的迁移研究的是如何找到源数据和目标数据的空间模型之间的共同参数或者先验分布，从而可以通过进一步处理，达到知识迁移的目的，假设前提是，学习任务中的的每个相关模型会共享一些相同的参数或者先验分布。</p>]]></content>
    
    
    <categories>
      
      <category>Machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Machine learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Smart Fuzz</title>
    <link href="/2019/06/02/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%20Smart%20Fuzz/"/>
    <url>/2019/06/02/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%20Smart%20Fuzz/</url>
    
    <content type="html"><![CDATA[<h1 id="文件类型漏洞挖掘与-Smart-Fuzz"><a href="#文件类型漏洞挖掘与-Smart-Fuzz" class="headerlink" title="文件类型漏洞挖掘与 Smart Fuzz"></a>文件类型漏洞挖掘与 Smart Fuzz</h1><p>​    不管是 IE 还是 Office，它们都有一个共同点，那就是用文件作为程序的主要输入。从本质上来说，这些软件都是按照事先约定好的数据结构对文件中不同的数据域进行解析，以决定用什么颜色、在什么位置显示这些数据。</p><p>​    不少程序员会存在这样的惯性思维，即假设他们所使用的文件是严格遵守软件规定的数据格式的。这个假设在普通的使用过程中似乎没有什么不妥——毕竟用 Word 生成的.doc 文件一般不会存在什么非法的数据。</p><p>​    但是攻击者往往会挑战程序员的假定假设，尝试对软件所约定的数据格式进行稍许修改，观察软件在解析这种“畸形文件”时是否会发生错误，发生什么样的错误，以及堆栈是否能被溢出等。</p><p>​    文件格式 Fuzz（File Fuzz）就是这种利用“畸形文件”测试软件鲁棒性的方法。您可以在Internet 上找到许多用于 File Fuzz 的工具。抛开界面、运行平台等因素不管，一个 File Fuzz 工</p><p>​    具大体的工作流程包括以下几步，如图 17.1.1 所示。</p><p>（1）以一个正常的文件模板为基础，按照一定规则产生一批畸形文件。</p><p>（2）将畸形文件逐一送入软件进行解析，并监视软件是否会抛出异常。</p><p>（3）记录软件产生的错误信息，如寄存器状态、栈状态等。</p><p>（4）用日志或其他 UI 形式向测试人员展示异常信息，以进一步鉴定这些错误是否能被利用。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224180213008.png" srcset="/img/loading.gif" alt="image-20200224180213008"></p><p>也就是说文件的fuzz的是指在一个基本的文件格式上进行篡改，得到畸形文件之后输入</p><h3 id="Blind-和-Smart"><a href="#Blind-和-Smart" class="headerlink" title="Blind 和 Smart"></a>Blind 和 Smart</h3><p>通常 Smart Fuzz 包括三方</p><ul><li>面的特征：面向逻辑（Logic Oriented Fuzzing): 理解程序运行逻辑改动特定位置精准打击</li><li>面向数据类型（Data Type Oriented Fuzzing）：面向数据类型测试是指能够识别不同的数据类型，并且能够针对目标数据的类型按照不同规则来生成畸形数据。</li><li>对基于样本（Sample Based Fuzzing）：测试前首先构造一个合法的样本文件（也叫模板文件），这时样本文件里所有数据结构和逻辑必然都是合法的。然后以这个文件为模板，每次只改动一小部分数据和逻辑来生成畸形文件，这种方法也叫做“变异”（Mutation）。</li></ul><h3 id="介绍一下屁吃（peach）"><a href="#介绍一下屁吃（peach）" class="headerlink" title="介绍一下屁吃（peach）"></a>介绍一下屁吃（peach）</h3><p>首先介绍其五个部分：</p><ol><li><p><strong>GeneralConf:</strong></p><p>这个是一些基本的设置比如导入的库这样的东西</p></li><li><p><strong>DataModel：</strong></p><p>这个是比较有意思的东西，就是表示数据的结构，其中有一些数据类型比如字符或数字还有block，组合</p><p>看个例子：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224183334186.png" srcset="/img/loading.gif" alt="image-20200224183334186"></p></li></ol><p>其中还可以使用一些函数比如计算校验值CRC或者是计算长度（sizeof), 例如：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224183450731.png" srcset="/img/loading.gif" alt="image-20200224183450731"></p><ol start="3"><li><p><strong>stateModel</strong>：</p><p>​    StateModel 元素用于描述如何向目标程序发送／接收数据。StateModel 由至少一个 State 组成，并且用 initialState 指定第一个 State；每个 State 由至少一个 Action 组成，Action 用于定义StateModel 中的各种动作，动作类型由 type 来指定。Action 支持的动作类型包括 start、stop、open、close、input、output、call 等。</p><p>​    我觉得就是一个动作序列吧。然后state是用来跳转的？</p></li></ol><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224183653922.png" srcset="/img/loading.gif" alt="image-20200224183653922"></p><ol start="4"><li><p><strong>Agent</strong></p><p>Agent用来设置代理监控程序</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224183754228.png" srcset="/img/loading.gif" alt="image-20200224183754228"></p></li><li><p><strong>Test &amp; Run configuration</strong></p></li></ol><p>之后就是使用之前定义好的一系列东西来定义一下test了，之后将test或者几个test run起来就可以了</p><p>Test 元素用来定义一个测试的配置，包括一个 StateModel 和一个 Publisher，以及includeing/excluding、Agent 信息等。其中 StateModel 和 Publisher 是必须定义的，其他是可选定义的。下面是一个 Test 配置的例子。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224183954285.png" srcset="/img/loading.gif" alt="image-20200224183954285"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224183940191.png" srcset="/img/loading.gif" alt="image-20200224183940191"></p><p>​    Publisher 做一下介绍。Publisher 用来定义 Peach 的 IO 连接，可以构造网络数据流（如TCP，UDP，HTTP）和文件流（如 FileWriter，FileReader）等。上例中的 Publisher 定义表示将生成的畸形数据写到 FuzzedFile 文件中。</p><p>​    现在到了最后一步，Run 的配置。Run 元素用来定义要运行哪些测试，包含一个或多个 Test，另外还可以通过 Logger 元素配置日志来捕获运行结果。当然，Logger 也是可选的。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200224184056795.png" srcset="/img/loading.gif" alt="image-20200224184056795"></p><h3 id="介绍一下010-script"><a href="#介绍一下010-script" class="headerlink" title="介绍一下010 script"></a>介绍一下010 script</h3><p>我感觉就是一种结构体吧，首先知道这个文件的结构，然后自己用结构体定义出来，然后read作用在这个文件上，文件中的数据映射到这个结构体中去然后康文件中的结构化的数据</p>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GS</title>
    <link href="/2019/05/30/%E6%A0%88%E7%9A%84%E5%AE%88%E6%8A%A4%E8%80%85-GS/"/>
    <url>/2019/05/30/%E6%A0%88%E7%9A%84%E5%AE%88%E6%8A%A4%E8%80%85-GS/</url>
    
    <content type="html"><![CDATA[<h1 id="栈的守护者-GS"><a href="#栈的守护者-GS" class="headerlink" title="栈的守护者-GS"></a>栈的守护者-GS</h1><p>​    首先介绍一下什么是GS，GS的出现很自然，因为我们把栈给溢出的也就是说把很多栈中的数据改变了，所以我们将其中的一处设置为一个security cookie，这样每次在返回的时候比较一下就可以知道是不是溢出了。</p><p>​    先介绍一下是如何生成security cookie的。</p><ul><li>首先从.data处的第一个双字选为所有函数的cookie随机种子。</li><li>在调用函数的时候，取这个种子跟EBP异或存在EB4-4的位置(security cookie)</li><li>这样在返回的时候先检查这个security cookie. 只要将这个security cookie取出来之后跟EBP异或之后再和存在.data 处的随机数比较就可以了。</li></ul><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200229181148344.png" srcset="/img/loading.gif" alt="image-20200229181148344"></p><p>​    因为这个数的比较是在函数返回之前的。所以无法利用函数溢出返回地址来执行shellcode。</p><p>​    现在的GS，有时候还会使用变量重排技术。就是把字符串网上调一点，使得更难去溢出。</p><p>如何去突破GS的机制呢</p><p>这里给出四种方法：</p><ul><li>使用C++虚函数表的漏洞</li><li>使用更改S E H的函数handler的方法</li></ul><hr><p>注意上面两种方法都具有这样一个特点：都是在返回之前实现了操作，接下来就不一样了</p><ul><li>直接硬刚，更改cookie和security cookie</li><li>利用没有GS的函数溢出来关闭GS</li></ul>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Heap overflow</title>
    <link href="/2019/05/28/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
    <url>/2019/05/28/%E5%A0%86%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><p>​    堆是一块动态分配的内存，不同于栈，这是不能在编译的时候决定的。是在运行的时候申请的，所以有可能失败也有可能成功。使用完毕之后必须把内存还给操作系统，否则会导致内存泄露。栈只有 pop 和 push 两种操作，总是在“线性”变化，其管理机制也相对简单，所以，栈溢出的利用很容易掌握。与“整齐”的栈不同，堆往往显得“杂乱无章”。</p><p><strong>堆块：</strong>出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227232519069.png" srcset="/img/loading.gif" alt="image-20200227232519069"></p><p><strong>堆表：</strong>堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构</p><p><strong>注意，堆表只索引空闲态的堆块</strong></p><p>空表：空闲双向链表</p><p>快表：快速单向链表</p><p>小块：SIZE &lt; 1KB </p><p>章</p><p>堆溢出利用150 </p><p>2</p><p>大块：1KB ≤ SIZE &lt; 512KB </p><p>巨块：SIZE ≥ 512KB</p><p>来看看windows是怎么管理的：</p><h4 id="空表"><a href="#空表" class="headerlink" title="空表"></a>空表</h4><p>堆区的开始用一个数组来指示128个表头（128个大小不同的表）</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227233451532.png" srcset="/img/loading.gif" alt="image-20200227233451532"></p><p>大小规律就是：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227233504677.png" srcset="/img/loading.gif" alt="image-20200227233504677"></p><p><strong>需要注意的是，空表索引的第一项（free[0]）所标识的空表相对比较特殊。这条双向链表链入了所有大于等于 1024 字节的堆块（小于 512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去，您会在稍后发现这样组织的好处。</strong></p><h4 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h4><p>快表是 Windows 用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块合并）。</p><p>快表也有 128 条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有 4 个结点，故很快就会被填满。</p><h3 id="堆的操作"><a href="#堆的操作" class="headerlink" title="堆的操作"></a>堆的操作</h3><h3 id="堆块分配"><a href="#堆块分配" class="headerlink" title="堆块分配"></a>堆块分配</h3><ol><li>快表分配：寻找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用</li><li>空表分配：首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小的能够满足要求的空闲块</li><li>零号快表分配：故在分配时先从 free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配（这就明白为什么零号空表要按照升序排列了）</li></ol><p>找零钱现象：就是无法匹配到最优的时候，拿个稍微大一些的，但是要切割，剩余的链入空表</p><p>快表只有在精确匹配的时候才会分配</p><h4 id="堆块合并"><a href="#堆块合并" class="headerlink" title="堆块合并"></a>堆块合并</h4><p>经过反复的申请与释放操作，堆区很可能变得“千疮百孔”，产生很多内存碎片。为了合理有效地利用内存，堆管理系统还要能够进行堆块合并操作，如图 5.1.4 所示。当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如大小等）将新块重新链入空闲链表。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227234923802.png" srcset="/img/loading.gif" alt="image-20200227234923802"></p><p>看一下堆分配和合并对于三种不同类型的块的不同策略</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227235103905.png" srcset="/img/loading.gif" alt="image-20200227235103905"></p><h2 id="来看点真实的"><a href="#来看点真实的" class="headerlink" title="来看点真实的"></a>来看点真实的</h2><p>Windows 中提供了许多类型的堆分配函数，您可以在 MSDN 中找到这些函数的详细说明。</p><p>所有的堆分配函数最终都将使用位于 ntdll.dll 中的 RtlAllocateHeap()函数进行分配，这个函数也是在用户态能够看到的最底层的堆分配函数。所谓万变不离其宗，这个“宗”就是RtlAllocateHeap()。因此，研究 Windows 堆只要研究这个函数即可。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227235653097.png" srcset="/img/loading.gif" alt="image-20200227235653097"></p><p>调试堆的时候不能用ollydbg， 因为会检测到使用了调试态</p><p>调试态堆管理策略和常态堆管理策略有很大差异，集中体现在：</p><p>（1）调试堆不使用快表，只用空表分配。</p><p>（2）所有堆块都被加上了多余的 16 字节尾部用来防止溢出（防止程序溢出而不是堆溢出攻击），这包括 8 个字节的 0xAB 和 8 个字节的 0x00。 </p><p>（3）块首的标志位不同。</p><p><strong>来看一个具体的例子</strong></p><h3 id="空表的过程"><a href="#空表的过程" class="headerlink" title="空表的过程"></a>空表的过程</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228004210421.png" srcset="/img/loading.gif" alt="image-20200228004210421"></p><p>tips：</p><ol><li><p>其中的__asm 是调用中断，为了让堆初始化好之后，再启用OD</p></li><li><p>系统是存在不同的堆区的，我们要首先获取操作堆区的句柄</p><ol><li><p>getprocessheap()获取特定堆区</p></li><li><p>malloc()使用特定堆区</p></li><li><p>heapcreate()创建新堆区</p><p>我们这里创建了新的堆区，是为了防止之前的堆区被拆得支离破碎不好观察</p></li></ol></li></ol><p>在拿到这个句柄之后去对应的内存 区域看堆区，这里是0x00520000 ，从 0x00520000 开始，堆表中包含的信息依次是段表索引（Segment List）、虚表索引(Virtual Allocation list)、空表使用标识（freelist usage bitmap）和空表索引区</p><p>我们主要看的是偏移 0x178 处的空表索引区</p><p>当一个堆刚刚被初始化时，它的堆块状况是非常简单的。</p><p>（1）只有一个空闲态的大块，这个块被称做“尾块”。</p><p>（2）位于堆偏移 0x0688 处（启用快表后这个位置将是快表），这里算上堆基址就是0x00520688。 </p><p>（3）Freelist[0]指向“尾块”。</p><p>（4）除零号空表索引外，其余各项索引都指向自己，这意味着其余所有的空闲链表中都没</p><p>有空闲块。</p><p>看一下堆块的结构</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228005748862.png" srcset="/img/loading.gif" alt="image-20200228005748862"></p><p>这个是占用块的结构，空闲块是一致的，只不过用了8个字节来做前后指针</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228005856979.png" srcset="/img/loading.gif" alt="image-20200228005856979"></p><p>（1）实际上这个堆块开始于 0x00520680，一般引用堆块的指针都会跃过 8 字节的块首，直接指向数据区。</p><p>（2）尾块目前的大小为 0x0130，计算单位是 8 个字节(分配不满八字节则按八字节分配，也就是说八字节是最小分配单位)，也就是 0x980 字节。</p><p>（3）注意：堆块的大小是包含块首在内的。</p><p>在这个例子中就是这样的：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228005940181.png" srcset="/img/loading.gif" alt="image-20200228005940181"></p><p>注意，<strong>快表不是所有的堆区都有的</strong></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228010014227.png" srcset="/img/loading.gif" alt="image-20200228010014227"></p><p>之后进行我们的分配策略</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228010228801.png" srcset="/img/loading.gif" alt="image-20200228010228801"></p><p>这是实际分配结果：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228010237913.png" srcset="/img/loading.gif" alt="image-20200228010237913"></p><p>​    关于怎么从哪里切割这一块下来，以及之后的大块是怎样的的，这里书上没有提到，但是根据之前说的和自己的理解，应该是直接就用大块的开始切下自己需要的，然后剩下的还就是大块。所以也可以看到，图中的6个堆区域分配都是连续的，而且之后跟的是大块</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228010354895.png" srcset="/img/loading.gif" alt="image-20200228010354895"></p><p>之后是释放：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228011104330.png" srcset="/img/loading.gif" alt="image-20200228011104330"></p><p>​    大家可以发现，这三个释放不是连续的，所以不会发生合并，从下图中可以看到，这三个块已经分配到三个链中去了。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228011520282.png" srcset="/img/loading.gif" alt="image-20200228011520282"></p><p>然后存虚表list的位置已经出现了新的链！(一开始是只有free[0]的)</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228012051757.png" srcset="/img/loading.gif" alt="image-20200228012051757"></p><p>之后的一步就是合并了，因为我们把h4 free了</p><p>首先将3个相邻的块摘下，重新计算大小</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228012630724.png" srcset="/img/loading.gif" alt="image-20200228012630724"></p><p>连续区域并起来辣！</p><p>可以看到，合并只修改了块首的数据，原块的块身基本没有发生变化。注意合并后的新块大小已经被修改为 0x0008，其空表指针指向 0x005201B8，也就是 freelist[8]。这时，在空表索引区观察一下，如图 5.2.15 所示。</p><p>可以看到：</p><p>（1）在 0x00520188 处的 freelist[2]，原来标识的空表中有两个空闲块 h1 和 h3，而现在只剩下 h1，因为 h3 在合并时被摘下了。</p><p>（2）在 0x00520198 处的 freelist[4]，原来标识的空表中有一个空闲块 h5，现在被改为指向自身，因为 h5 在合并时被摘下了。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228012747545.png" srcset="/img/loading.gif" alt="image-20200228012747545"></p><p>接下来我们看一下快表</p><h3 id="快表的过程"><a href="#快表的过程" class="headerlink" title="快表的过程"></a>快表的过程</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228013036267.png" srcset="/img/loading.gif" alt="image-20200228013036267"></p><p>需要注意的是程序在使用快表之后堆结构也会发生一些变化，其中最为主要的变化是“尾块”不在位于堆 0x0688 偏移处了，这个位置被快表霸占。从偏移 0x0178 处的空表索引区也可以看出这一点</p><p>注意啊我们现在来区分几个概念</p><p>快表的指示位置：688</p><p>空表的指示位置:   178</p><p>空表的实际位置：688(无快表的时候)， 有快表就要看178一开始的指示的尾块位置了</p><p>快表的实际位置：没必要的，因为就是从大空表上拿下来的</p><p>我们可以看到h2,h3,h4分别申请了8，16，24，之后释放是回到快表中去的。回去之后的状态：</p><p>注意块首的区别就在于这是一个单向链表。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200228013831097.png" srcset="/img/loading.gif" alt="image-20200228013831097"></p>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>System</tag>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASLR</title>
    <link href="/2019/05/28/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/"/>
    <url>/2019/05/28/%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E8%BA%B2%E7%8C%AB%E7%8C%AB%EF%BC%9AASLR/</url>
    
    <content type="html"><![CDATA[<h1 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h1><p>​    纵观前面介绍的所有漏洞利用方法都有着一个共同的特征：都需要确定一个明确的跳转地址。无论是 JMP E SP 等通用跳板指令还是 Ret2Libc 使用的各指令，我们都要先确定这条指令的入口点。所谓惹不起躲得起，微软的 ASLR（Address Space Layout Randomization）技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰 shellcode 定位的一种保护机制。</p><p>​    我们前面提到 ASLR 在 Windows Vista 之后的操作系统上才真正的发挥作用，它包含了映像随机化、堆栈随机化、PEB 与 TEB 随机化，接下来我们看看每一项的细节。</p><p>​    注意，随机化的是虚拟地址。</p><p><strong>1</strong>．<strong>映像随机化</strong></p><p>​    映像随机化是在 PE 文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启后这个地址会变化。我们以 IE 为例来看看 Windows Vista 开 启 ASLR 后各模块加载的微妙之处。我们用 OllyDbg 加载 IE 并记录其加载模块的地址，然后重启系统后再记录一次，如图 13.1.2 所示 IE 的各加载模块基址在系统重启会是变化的。</p><p>eg: .data 变了， 这样你想要突破GS就不行了, 而且那些模块，跳板指令不能用了。</p><p><strong>2</strong>．<strong>堆栈随机化</strong></p><p>​    这项措施是在程序运行时随机的选择堆栈的基址，与映像基址随机化不同的是堆栈的基址不是在系统启动的时候确定的，而是在打开程序的时候确定的，也就是说同一个程序任意两次运行时的堆栈基址都是不同的，进而各变量在内存中的位置也就是不确定的。</p><p>eg：堆栈随机化了，这样你确定buffer的开头就不行了</p><p><strong>3．PEB 与 TEB 随机化</strong></p><p>PEB 与 TEB 随机化在 Windows XP SP2 中就已经引入了，微软在 XP SP2 之后不再使用固定的 PEB 基址 0x7FFDF000 和 TEB 基址 0x7FFDE000，而是使用具有一定随机性的基址，这就增加了攻击 PEB 中的函数指针的难度。</p><p>PEB: 偏移0x20处存放RtlEnterCriticalSection(), 这是ExitProcess必须要做的(堆溢出的利用)</p><p>TEB: 会用来获取API位置</p><p>eg：这样你就不能使用DWORD SHOOT 来处理RtlEnterCriticalSection()的函数指针了。</p><p><strong>如何突破ASLR</strong></p><h3 id="攻击未启用-ASLR-的模块"><a href="#攻击未启用-ASLR-的模块" class="headerlink" title="攻击未启用 ASLR 的模块"></a>攻击未启用 ASLR 的模块</h3><p>​    ASLR 仅仅是项安全机制，不是什么行业标准，不支持 ASLR 的软件有很多。不支持 ASLR意味着加载基址固定，如果我们能够在当前进程空间中找到一个这样的模块，就可以利用它里边的指令来做跳板了，直接无视 ASLR。这样的模块还不难找，就有一个摆在我们面前，这个模块就是大名鼎鼎的 Adobe Flas h Player ActiveX。</p><h3 id="利用-Heap-spray-技术定位内存地址"><a href="#利用-Heap-spray-技术定位内存地址" class="headerlink" title="利用 Heap spray 技术定位内存地址"></a>利用 Heap spray 技术定位内存地址</h3><p>​    通过申请大量的内存，(申请200M)占领内存中的 0x0C0C0C0C的位置，之后JMP到这里，并在这些内存中放置 0x90 和 shellcode，最后控制程序转入 0x0C0C0C0C 执行。只要运气不要差到 0x0C0C0C0C 刚好位于 shellcode 中的某个位置，shellcode 就可以成功执行。</p><p>大家可能会有所顾虑，因为 ASLR 对堆基址做了随机化处理，如果它将堆基址随机到0x0C0C0C0C 之后怎么办？事实上这种情况不会发生。</p>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell code injection</title>
    <link href="/2019/05/25/%E4%BB%A3%E7%A0%81%E6%A4%8D%E5%85%A5/"/>
    <url>/2019/05/25/%E4%BB%A3%E7%A0%81%E6%A4%8D%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="shell-code代码植入"><a href="#shell-code代码植入" class="headerlink" title="shell code代码植入"></a>shell code代码植入</h1><p>首先我们复习一下汇编的相关知识</p><p>函数Giao用</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227173909157.png" srcset="/img/loading.gif" alt="image-20200227173909157"></p><ul><li><p>开新的栈帧，下面依次是ebp，断点地址，参数。</p></li><li><p>然后esp在老上头，上面存着edi，esi这些之前寄存器的值。</p></li><li><p>此时的ebp是定海神针，局部变量的操作都是靠他来定位</p></li><li><p>然后写入局部变量就是先来后到从下往上写</p></li><li><p>返回的时候弹回之前的东西，然后断点给EIP，之后esp+N(淹没参数)</p></li></ul><p>这个0 days上给的其实跟我们做的软安实验是如出一辄的，只不过他的植入是在buffer的顶部开始植入，而我们的软安课设是JMP ESP 到下面去执行，也就是一个在覆盖地址前面，一个在覆盖地址后面，而且更重要的区别在于我们用JMP ESP 是更稳定的，如果定位到一个特定的位置，由于动态加载，很可能下次就用不了了。</p><p>好我们把shellcode 的相关东西都拿来，注意，这里讨论是纯粹讨论是可以在栈中进行执行的</p><h1 id="shellcode-的升级历程"><a href="#shellcode-的升级历程" class="headerlink" title="shellcode 的升级历程"></a>shellcode 的升级历程</h1><h3 id="JMP-ESP"><a href="#JMP-ESP" class="headerlink" title="JMP ESP"></a>JMP ESP</h3><p>这个方法是软安实验中用的，目的就是保证每次地址变换之后还能找到shellcode，因为这样是一个相对的概念，不是绝对寻址。</p><p>但是我们同时也要注意到，我们这样是需要把shellcode写在esp下面的。这样是有坏处的，一般来说shellcode会比较长，这样就会导致下一个栈帧被破坏导致不能正常返回。</p><h3 id="利用JMP-ESP之后加一个header"><a href="#利用JMP-ESP之后加一个header" class="headerlink" title="利用JMP ESP之后加一个header"></a>利用JMP ESP之后加一个header</h3><p>加了一个header之后可以让程序返回到上面的缓冲区去执行，注意，这里跟之前的区别在于，我们可以控制回到的位置！</p><h3 id="抬高栈顶保护shellcode"><a href="#抬高栈顶保护shellcode" class="headerlink" title="抬高栈顶保护shellcode"></a>抬高栈顶保护shellcode</h3><p>注意到，我们将JMP ESP之后，我们是将ESP留在了shellcode的下方的，这样的话，如果本身shellcode需要压入数据而且如果shellcode离得不远，就自己把自己给覆盖了。</p><p>所以！我们在一开始执行shellcode的时候需要先把栈顶抬到shellcode上去，就是说sub esp， xxx这样！</p><h3 id="返回不确定"><a href="#返回不确定" class="headerlink" title="返回不确定"></a>返回不确定</h3><p>当返回地址有时候不确定的话，这时候我们可以多加一点nop指令和加入大量的返回区域指令，这样把靶子弄大了就能保证能够进入区域。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227215028650.png" srcset="/img/loading.gif" alt="image-20200227215028650"></p><h3 id="进一步通用，定位API"><a href="#进一步通用，定位API" class="headerlink" title="进一步通用，定位API"></a>进一步通用，定位API</h3><p>因为我们之前找API的方法是直接打开dll，然后开始找，但是这样换一台机子就没了。</p><p>于是我们要跟windows找API那样，找到一个字典来对应到API</p><p>于是有这样的操作：</p><ol><li><p>在段选择字中找到当前的线程环境块TEB</p></li><li><p>在TEB的偏移0x30的位置找到进程环境块PEB</p></li><li><p>PEB的偏移0x0C的位置存放着PEB_LDR_DATA的指针</p></li><li><p>PEB_LER_DATA偏移为0x1C的位置存放模块初始化指针InInitializationOrderModuleList</p></li><li><p>InInitializationOrderModuleList 中按顺序存放着 PE 装入运行时初始化模块的信息，第一个链表结点是 ntdll.dll，第二个链表结点就是 kernel32.dll。</p></li><li><p>找到属于 kernel32.dll 的结点后，在其基础上再偏移 0x08 就是 kernel32.dll 在内存中的</p><p>加载基地址。</p><p>从 kernel32.dll 的加载基址算起，偏移 0x3C 的地方就是其 PE 头。PE 头偏移 0x78 的地方存着指向函数导出表的指针。</p></li><li><p>找到函数导出表</p></li></ol><p>找到导出表了就OK辣！</p><p>有名称就能找到对应的位置，然后就是RVA+基址就可以了</p><p>注意，这里，也是有可以升级的地方，可以用hash值代替函数名，但是同样的，要把hash函数附上，用来hash表中的名字</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227230729023.png" srcset="/img/loading.gif" alt="image-20200227230729023"></p><p>Tips：如果有dll没有加载进来需要使用loadlibrary</p><h3 id="shellcode编码技术"><a href="#shellcode编码技术" class="headerlink" title="shellcode编码技术"></a>shellcode编码技术</h3><p>因为现在有检测shellcode的程序了已经，所以要把他包装起来，利用的编码的方法：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200227230904573.png" srcset="/img/loading.gif" alt="image-20200227230904573"></p><h3 id="shellcode-的“瘦身’’"><a href="#shellcode-的“瘦身’’" class="headerlink" title="shellcode 的“瘦身’’"></a>shellcode 的“瘦身’’</h3><p>因为很多时候留给shellcode的空间并不多</p><ol><li><p><strong>挑选短指令</strong></p></li><li><p><strong>代码数据混用：准nop指令</strong></p></li><li><p><strong>善用寄存器</strong></p></li><li><p><strong>hash</strong></p><p>选取原则：</p><ol><li>减少冲突</li><li>摘要达到8bit最合适</li><li>能多有准nop指令最好</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Software security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Software security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
