<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows Objects and Poll Allocations</title>
    <link href="/2020/03/10/Windows-Objects-and-Poll-Allocations/"/>
    <url>/2020/03/10/Windows-Objects-and-Poll-Allocations/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-Objects-and-Poll-Allocations"><a href="#Windows-Objects-and-Poll-Allocations" class="headerlink" title="Windows Objects and Poll Allocations"></a>Windows Objects and Poll Allocations</h1><blockquote><p>​    All the artifacts that you find in memory dumps share a common origin: They all start out as an allocation. How, when, and why the memory regions were allocated sets them apart, in addition to the actual data stored within and around them. From a memory forensics perspective, studying these characteristics can help you make inferences about the content of an allocation, leading to your ability to find and label specific types of data throughout a large memory dump. Furthermore, becoming familiar with the operating system’s algorithms for allocation and de-allocation of memory can help you understand the context of data when you find it—for example, whether it is currently in use or marked as free. </p><p>​    This chapter introduces you to the concepts of Windows executive objects, kernel pool allocations, and pool tag scanning. Specifically, you will use this knowledge to find objects (such as processes, files, and drivers) by using a method that is independent of how the operating system enumerates the objects. Thus, you can defeat rootkits that try to hide by manipulating the operating system’s internal data structures. Furthermore, you can identify objects that were used but have since been discarded (but not overwritten), giving you valuable insight into events that occurred in the past.</p></blockquote><h3 id="windows对象"><a href="#windows对象" class="headerlink" title="windows对象"></a>windows对象</h3><p>我对windows的对象理解就是说：</p><p>windows的对象是windows用于管理的资源的手段，object中相当于存了相关资源的handler，特权级等信息</p><p>然后object是由object manager管理的。</p><p>一般的object</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307101217704.png" srcset="/img/loading.gif" alt="image-20200307101217704"></p><h4 id="对象头部"><a href="#对象头部" class="headerlink" title="对象头部"></a>对象头部</h4><p>对象头部包括 _OBJECT_HEADER 和 可选头部，对于不同的object可选头部是不一样的。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307101614544.png" srcset="/img/loading.gif" alt="image-20200307101614544"></p><p>先看一下_OBJECT_HEADER </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dt(&quot;_OBJECT_HEADER&quot;)</span><br><span class="line">&#39;_OBJECT_HEADER&#39; (56 bytes)</span><br><span class="line">0x0 : PointerCount [&#39;long long&#39;]</span><br><span class="line">0x8 : HandleCount [&#39;long long&#39;]</span><br><span class="line">0x8 : NextToFree [&#39;pointer64&#39;, [&#39;void&#39;]]</span><br><span class="line">0x10 : Lock [&#39;_EX_PUSH_LOCK&#39;]</span><br><span class="line">0x18 : TypeIndex [&#39;unsigned char&#39;]</span><br><span class="line">0x19 : TraceFlags [&#39;unsigned char&#39;]</span><br><span class="line">0x1a : InfoMask [&#39;unsigned char&#39;]</span><br><span class="line">0x1b : Flags [&#39;unsigned char&#39;]</span><br><span class="line">0x20 : ObjectCreateInfo [&#39;pointer64&#39;, [&#39;_OBJECT_CREATE_INFORMATION&#39;]]</span><br><span class="line">0x20 : QuotaBlockCharged [&#39;pointer64&#39;, [&#39;void&#39;]]</span><br><span class="line">0x28 : SecurityDescriptor [&#39;pointer64&#39;, [&#39;void&#39;]]</span><br><span class="line">0x30 : Body [&#39;_QUAD&#39;]</span><br></pre></td></tr></table></figure><p>具体含义:</p><ul><li><p>pointercounter：所有的对该应用的引用，包括内核引用</p></li><li><p>TypeIndex: Object type object(后面会提到)的数组索引，这里可以理解为是确定这个object是什么类型的object</p></li><li><p>InfoMask: 包含了哪些可选头部</p></li><li><p>SecurityDescriptor: 有关安全信息，比如哪些用户可以访问这个对象</p></li></ul><p>对于可选头部，同一类型的每个对象可能不同。</p><p>一些可选头部:<br><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307102304096.png" srcset="/img/loading.gif" alt="image-20200307102304096"></p><p>其中的bit mask 应该就是对应到之前的infomask</p><h4 id="Object-type-object"><a href="#Object-type-object" class="headerlink" title="Object type object"></a>Object type object</h4><p>对象类型对象，什么意思呢，可以理解为对这种类型对象的一个概括吧，也就是说对象类型对象中存储了对应的对象的一些基本信息，有点像抽象类。</p><p>header中的TypeIndex就是一个索引，这个索引指的就是该对象类型在nt!ObTypeIndexTable这个array中的序号，从而指出这个对象是什么类型。</p><p>书中一段话</p><blockquote><p>For example, process handle table entries (see Chapter 6) point to object headers. Thus, when you enumerate entries in a handle table, the type of data that follows the header is arbitrary—it could be a _FILE_OBJECT, _EPROCESS, or any other executive object. You can distinguish between the various possibilities by looking at the TypeIndex value, locating the _OBJECT_TYPE that corresponds to the index, and then evaluating the Name member. Refer to Table 5-1 for the mappings between object type names and their structure names. </p></blockquote><p>其中的process handle table 就是学到过的进程中对于资源的一些句柄表(类似于文件打开表，但不限于文件)，比如开了一个文件，文件object的句柄就会存在这个进程中，当然我们也知道，我们打开文件之后不仅仅是在当前进程的handle table中加入handle，而且要在系统打开表中加入这个handle对吧，而这个系统打开表，就是之后要提到的pool。</p><p>object type 的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dt(&quot;_OBJECT_TYPE&quot;)</span><br><span class="line">&#39;_OBJECT_TYPE&#39; (208 bytes)</span><br><span class="line">0x0 : TypeList [&#39;_LIST_ENTRY&#39;]</span><br><span class="line">0x10 : Name [&#39;_UNICODE_STRING&#39;]</span><br><span class="line">0x20 : DefaultObject [&#39;pointer64&#39;, [&#39;void&#39;]]</span><br><span class="line">0x28 : Index [&#39;unsigned char&#39;]</span><br><span class="line">0x2c : TotalNumberOfObjects [&#39;unsigned long&#39;]</span><br><span class="line">0x30 : TotalNumberOfHandles [&#39;unsigned long&#39;]</span><br><span class="line">0x34 : HighWaterNumberOfObjects [&#39;unsigned long&#39;]</span><br><span class="line">0x38 : HighWaterNumberOfHandles [&#39;unsigned long&#39;]</span><br><span class="line">0x40 : TypeInfo [&#39;_OBJECT_TYPE_INITIALIZER&#39;]</span><br><span class="line">0xb0 : TypeLock [&#39;_EX_PUSH_LOCK&#39;]</span><br><span class="line">0xb8 : Key [&#39;unsigned long&#39;]</span><br><span class="line">0xc0 : CallbackList [&#39;_LIST_ENTRY&#39;]</span><br></pre></td></tr></table></figure><p>其中:</p><p>Name: 对象的Unicode编码</p><p>TotalNumberOfObjects：该object type对应的类型对象在系统中的数目</p><p>TotalNumberOfHandles：对于该种类型对象的总handler个数。</p><p>TypeInfo：这是一个_OBJECT_TYPE_INITIALIZER结构，其中包含了运用那种内存来分配这个Object，比如分页或是不分页</p><p>Key: 这是个很关键的数据，这个就是我们之后要提到的tag，一个四字节的tag来标识不同的object，比如proc代表process类型object</p><p>我们可以通过objectscan来看对应的OBJECT_TYPE在内存中的偏移</p><p>eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python vol.py -f win7x64cmd.dd --profile&#x3D;Win7SP0x64 objtypescan</span><br></pre></td></tr></table></figure><h3 id="池分配"><a href="#池分配" class="headerlink" title="池分配"></a>池分配</h3><p>我感觉，windows 的 pool 就是内核的堆吧，跟堆类似，在这段内存存的时候前面都会带一个_POOL_HEADER</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307111031984.png" srcset="/img/loading.gif" alt="image-20200307111031984"></p><p>再看一下_POOL_HEADER的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dt(&quot;_POOL_HEADER&quot;)</span><br><span class="line">&#39;_POOL_HEADER&#39; (16 bytes)</span><br><span class="line">0x0 : BlockSize [&#39;BitField&#39;, &#123;&#39;end_bit&#39;: 24,</span><br><span class="line"> &#39;start_bit&#39;: 16, &#39;native_type&#39;: &#39;unsigned long&#39;&#125;]</span><br><span class="line">0x0 : PoolIndex [&#39;BitField&#39;, &#123;&#39;end_bit&#39;: 16,</span><br><span class="line"> &#39;start_bit&#39;: 8, &#39;native_type&#39;: &#39;unsigned long&#39;&#125;]</span><br><span class="line">0x0 : PoolType [&#39;BitField&#39;, &#123;&#39;end_bit&#39;: 32,</span><br><span class="line"> &#39;start_bit&#39;: 24, &#39;native_type&#39;: &#39;unsigned long&#39;&#125;]</span><br><span class="line">0x0 : PreviousSize [&#39;BitField&#39;, &#123;&#39;end_bit&#39;: 8,</span><br><span class="line"> &#39;start_bit&#39;: 0, &#39;native_type&#39;: &#39;unsigned long&#39;&#125;]</span><br><span class="line">0x0 : Ulong1 [&#39;unsigned long&#39;]</span><br><span class="line">0x4 : PoolTag [&#39;unsigned long&#39;]</span><br><span class="line">0x8 : AllocatorBackTraceIndex [&#39;unsigned short&#39;]</span><br><span class="line">0x8 : ProcessBilled [&#39;pointer64&#39;, [&#39;_EPROCESS&#39;]]</span><br><span class="line">0xa : PoolTagHash [&#39;unsigned short&#39;]</span><br></pre></td></tr></table></figure><p>其中，</p><p>BlockSize: 这个是指分配的空间大小，包括一堆header，这个倒是跟堆一样，头中大小是包含整个的。</p><p>PoolType: 指分配了哪种内存，分页或是不分页</p><p>PoolTag: 这就是我们之前说到的tag，相当于是类的一个标记吧，我们在做psscan的时候就是扫描内存找这个玩意，然后找到proc，确定这里是process project，在win8之后，这个四字节的tag其中会有一个叫做protected bit的东西。</p><h4 id="分配对象的API"><a href="#分配对象的API" class="headerlink" title="分配对象的API"></a>分配对象的API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">ExAllocatePoolWithTag</span><span class="params">( _In_ POOL_TYPE PoolType, </span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">                  In_ SIZE_T NumberOfBytes, _In_ ULONG Tag )</span></span>;</span><br></pre></td></tr></table></figure><p>PoolType是指分配类型，是分页还是不分页，</p><blockquote><p>As previously shown, most, but not all, executive object types are allocated using nonpageable memory—and you can always make the distinction by looking at a particular object’s _OBJECT_TYPE.TypeInfo.PoolType member.</p></blockquote><p>Tag 就是之前提到的那个玩意，tag确定了用什么函数，多态？</p><blockquote><p>The Tag argument specifies a four-byte value, typically composed of ASCII characters that should uniquely identify the code path taken to produce the allocation (so troublesome blocks can be traced back to their source). In the case of executive objects, the tags are derived from the _OBJECT_TYPE.Key member—which explains why the Tag is the same for all objects of a particular type</p></blockquote><p>分配对象的API 的一个流程，拿文件object举个例子：</p><ol><li>进程调用CreateFileA (ASCII) or CreateFileW (Unicode)，这俩都是从kernel32中导出的</li><li>然后这俩货之后会指向ntdll.dll, 最终倒向原生函数NtCreateFile</li><li>NtCreatFile会调用ObCreateObject去创建新的文件对象</li><li>ObCreateObject计算文件对象的大小</li><li>ObCreateObject找到对应的OBJECT_TYPE结构然后确定tag是哪个</li><li>最后调用刚刚提到的ExAllocatePoolWithTag，分配</li><li>之后一个指向对象头部的指针就加入到该进程的文件打开表中，系统的pooltag跟踪数据库(系统打开表)也会更新。</li></ol><p>Question</p><blockquote><p> a system-wide pool tag tracking database is updated accordingly, and the individual members of the _FILE_OBJECT are initialized with the path to the file being created and the requested access permissions </p></blockquote><p>这个system-wide pool tag tracking database或者说是系统打开表具体是指什么?</p><h4 id="对象的释放"><a href="#对象的释放" class="headerlink" title="对象的释放"></a>对象的释放</h4><p>跟大多数对象一样，分配之后释放，只是取消占用，但是不会抹除，所以会在内存驻留一段时间。所以释放的对象还是可以被侦测到的。</p><blockquote><p>Exactly how long the memory block lingers in this state depends on the activity level of the system. If the machine is thrashing, and the sizes of blocks being requested are less than or equal to the size of _FILE_OBJECT, it will be overwritten quickly. Otherwise, the object could persist for days or weeks—long after the process that created the file  Windows Objects and Pool Allocations 129 has terminated. In the past, students frequently asked this: After a network connection is closed, how soon must memory be acquired in order to preserve the evidence? The answer is that it’s unpredictable and can vary per machine or even time of day</p></blockquote><p>重要角色登场：</p><h3 id="POOL-TAG-SCANNIG"><a href="#POOL-TAG-SCANNIG" class="headerlink" title="POOL TAG SCANNIG"></a>POOL TAG SCANNIG</h3><p>其实我感觉挺憨的，就是在内存中遍历，找tag</p><p>文中自己也说了，如果光找tag肯定是不够的，还要配上一些相关信息，比如块大小等等，这里给出了一般的tag配套的信息。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307115449961.png" srcset="/img/loading.gif" alt="image-20200307115449961"></p><p>这里讲一下之前提到的protected bit，这是为了保证操作系统不会误操作而提供的，当在释放这个对象的时候，必须提供跟分配时候一样的的protected bit，防止误操作，感觉挺迷的这个操作，详见书P130</p><p>注意到，这个tag实际上是用于Windbg的(实际上去掉或者修改这些并不会影响运行), 所以Windbg中给出了对pooltag的表述，我们可以看每个版本的windows的dbg下的pooltag.txt, 这个文件描述了该版本windows下的pooltag</p><p>还有对应的工具PoolMon，用来监视系统中的pooltag，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\WinDDK\7600.16385.1\tools\Other\i386&gt; poolmon.exe -b</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307120552514.png" srcset="/img/loading.gif" alt="image-20200307120552514"></p><p>一段解释(翻译不动了，好累啊我晕了)：</p><p>As you can see, CM31 ranks highest in byte count. Since the system started, there have been 169,392 calls to ExAllocatePoolWithTag for the CM31 tag, and 153,744 of them have been freed. This leaves the difference of 15,648 currently allocated blocks, together consuming 74,838,016 bytes (approximately 75MB) of memory. On average, that’s 4,782 bytes per allocation</p><p>注意到，这个poolmon是用于正在运行的机器上的，但如果我们只有一段内存快照可以么？也是可以的，因为里面有poolmon需要的 kernel debugger data block ( <strong>_KDDEBUGGER_DATA64</strong>) ，记住这个名词！</p><p>这个block 中存了活动的进程以及加载的模块，具体一点，其中的 PoolTrackTable成员指向了一个数组，其中是 _POOL_TRACKER_TABLE 结构，这个结构记录了使用中的tag和其信息。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307121139267.png" srcset="/img/loading.gif" alt="image-20200307121139267"></p><hr><p><strong>Attention</strong></p><p>我觉得这个就是之前我想问的系统打开表，但是问题又来了，既然有系统打开表存在，我们为什么需要去扫描整个内存去找到这些OBbect呢?</p><hr><p>继续，</p><p>这个key就是tag哈, 我们的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python vol.py -f win7x64.dd pooltracker</span><br><span class="line"> --profile&#x3D;Win7SP0x64</span><br><span class="line"> --tags&#x3D;Proc,File,Driv,Thre</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307121308812.png" srcset="/img/loading.gif" alt="image-20200307121308812"></p><p>接下来就说了怎么去写一个poolscanner，这比较简单，详见P136</p><p>这里给个demo</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolScanProcess</span><span class="params">(poolscan.PoolScanner)</span>:</span></span><br><span class="line"><span class="number">2</span> <span class="string">"""Pool scanner for process objects"""</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, address_space, **kwargs)</span>:</span></span><br><span class="line"><span class="number">5</span> poolscan.PoolScanner.__init__(self, address_space, **kwargs)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> self.struct_name = <span class="string">"_EPROCESS"</span></span><br><span class="line"><span class="number">8</span> self.object_type = <span class="string">"Process"</span></span><br><span class="line"><span class="number">9</span> self.pooltag = obj.VolMagic(address_space).ProcessPoolTag.v()</span><br><span class="line"><span class="number">10</span>size = self.address_space.profile.get_obj_size(<span class="string">"_EPROCESS"</span>)</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span> self.checks = [</span><br><span class="line"><span class="number">13</span> (<span class="string">'CheckPoolSize'</span>, dict(condition = <span class="keyword">lambda</span> x: x &gt;= size)),</span><br><span class="line"><span class="number">14</span> (<span class="string">'CheckPoolType'</span>, dict(non_paged = <span class="literal">True</span>, free = <span class="literal">True</span>)),</span><br><span class="line"><span class="number">15</span>  (<span class="string">'CheckPoolIndex'</span>, dict(value = <span class="number">0</span>)),</span><br><span class="line"><span class="number">16</span> ]</span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307121706505.png" srcset="/img/loading.gif" alt="image-20200307121706505"></p><blockquote><p>If you scan using a physical address space, the code starts looking for the four-byte pool tag at offset 0 of the memory dump file and continues until it reaches the end of the file. Otherwise, if a virtual address space is selected, it enumerates and scans all pages in the kernel’s page table</p></blockquote><p>书中也给出psscan的短处，详见书P141</p><p>不是故意让psscan找不到的的:</p><ul><li>Untagged pool memory: 有些API分配object的时候，是不需要打标签的</li><li>False positives：</li><li>Large allocations：大块分配跟小块分配(指之前我们看到的Object结构)不同</li></ul><p>故意让psscan找不到:</p><ul><li>Arbitrary tags</li><li>Decoy tags：假标签</li><li>Manipulated tags：认为篡改标签</li></ul><h3 id="Big-page-pool"><a href="#Big-page-pool" class="headerlink" title="Big page pool"></a>Big page pool</h3><p>来介绍一下刚刚提到的大块</p><p>Windows 的kernel pool也喜欢将类似大小的块放在一起（应该是为了方便随机访问），这一点跟堆是类似的。然后有些巨大的块(大于4096字节)就是单独放的，就不会加header，用之前提到的big page track table 来索引</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200307122942559.png" srcset="/img/loading.gif" alt="image-20200307122942559"></p><h4 id="Big-Page-Track-table"><a href="#Big-Page-Track-table" class="headerlink" title="Big Page Track table"></a>Big Page Track table</h4><p>哇竟然找到了我之前那个问题的答案</p><blockquote><p>the pool track tables ( _POOL_TRACKER_TABLE) for small memory blocks store statistics regarding the number of allocations and byte usage; but they don’t tell you the addresses of all the allocations (thus the need to scan)</p></blockquote><p>但是大表就不一样，他存储了大块的分配位置，所以甚至可以拿它来定位大块而不需要scan。</p><blockquote><p>Unfortunately, the kernel symbol nt!PoolBigPageTable, which points to the array of _POOL_TRACKER_BIG_PAGES structures, (one for each large allocation), is neither exported nor copied to the kernel debugger data block. However, we discovered that this symbol can always be found at a predictable location relative to nt!PoolTrackTable (which is copied to the debugger data block). Thus, if you can find the pool track tables, you can find the big page track tables easily.</p></blockquote><p>大表在小表旁边</p><p>看一下大表的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dt(&quot;_POOL_TRACKER_BIG_PAGES&quot;)</span><br><span class="line">&#39;_POOL_TRACKER_BIG_PAGES&#39; (24 bytes)</span><br><span class="line">0x0 : Va [&#39;pointer64&#39;, [&#39;void&#39;]]</span><br><span class="line">0x8 : Key [&#39;unsigned long&#39;]</span><br><span class="line">0xc : PoolType [&#39;unsigned long&#39;]</span><br><span class="line">0x10 : NumberOfBytes [&#39;unsigned long long&#39;]</span><br></pre></td></tr></table></figure><p>va就是大块的位置</p><blockquote><p>Keep in mind that although this structure stores the pool tag, it is in a completely different location from the allocation, which is pointed to by Va. For small allocations, the pool tag is contained within the allocation (recall what you saw in Figure 5-4).</p></blockquote><p>接下来就是介绍了一下有关大表的插件，这个没什么好看的。</p><h3 id="Alternatives"><a href="#Alternatives" class="headerlink" title="Alternatives"></a>Alternatives</h3><p>因为poolscan有他不足的地方，所以还有其他方法</p><h4 id="Dispatcher-Header-Scan"><a href="#Dispatcher-Header-Scan" class="headerlink" title="Dispatcher Header Scan"></a>Dispatcher Header Scan</h4><p>总的来说就是利用系统存的一些同步信息来定位object，同步信息是指一些比如同步进程线程用的标志之类的。</p><p>但是缺点也很明显，就是非同步的object就无法scan， 比如文件object</p><h4 id="Robust-Signature-Scans"><a href="#Robust-Signature-Scans" class="headerlink" title="Robust Signature Scans"></a>Robust Signature Scans</h4><p>这个是指很多我们之前scan的tag是无关紧要的，就是说修改或是去掉都不影响运行，所以很多时候attacker会修改或者去掉这些，所以我们需要找无法修改的更加鲁棒的信息，这是一些人通过每次改变一个值的fuzz来找到的，发现有些信息被篡改之后就会蓝屏，所以就找这些信息来查找。</p><p>对应到volatility的插件是psscan3，但是这个不在默认包中，需要自己去下载</p><p>有这些鲁棒信息:<br> • DTB alignment: The DirectoryTableBase must be aligned on a 32-bit boundary. •     Granted access flags: The GrantedAccess member must have the 0x1F07FB flags set.</p><p> • Pointer validity: The VadRoot, ObjectTable, ThreadListHead, and ReadyListHead members must all contain valid kernel mode addresses.</p><p> • Working set list: The VmWorkingSetList member must not only point in kernel mode but it also needs to be above 0xC0000000 (for 32-bit systems). </p><p> • Lock counts: The WorkingSetLock and AddressCreationLock counts must be equal to 1.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>windows为了管理资源(进程，文件等)，为他们创建了Object，这些Object可以理解为他们的档案，然后Object也有分类，就好像把军队分成了后勤，医疗。而对于这些后勤，医疗的描述就是用Object type object来描述。所有的这些归中央军委Object manager管。</p><p>我们现在要寻找在战场(RAM)中找到一些突击兵，查看是否是间谍，我们一个一个扫描，我们可以查看他身上带着的四个字节身份证(tag), 发现是突击兵tag之后，再进一步通过其他信息比如身上子弹多少(块大小)等信息进一步确认。</p><p>由于是一些小兵，总部的档案库中不会存放他们打仗时每个人在什么位置，所以要一个一个找，但是一些军官(big page)，会在档案馆中记录他们的位置(big page track table)，只需要找军官的档案就可以</p><p>但是间谍很心机，他会修改自己的一些不影响大局的东西(debug信息)比如造假身份证躲过扫描，所以新一代计算需要利用不可修改的东西来扫描，比如指纹(鲁棒信息)等。</p>]]></content>
    
    
    <categories>
      
      <category>Memory Forensics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>system</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hunting Malware</title>
    <link href="/2020/03/10/Hunting-Malware/"/>
    <url>/2020/03/10/Hunting-Malware/</url>
    
    <content type="html"><![CDATA[<h1 id="Hunting-Malware-in-Process-Memory"><a href="#Hunting-Malware-in-Process-Memory" class="headerlink" title="Hunting Malware in Process Memory"></a>Hunting Malware in Process Memory</h1><blockquote><p>The previous chapter introduced you to process memory internals and set the foundations for you to deep dive into analysis. Now you’ll see some specific examples of how you can detect malware that hides in process memory by unlinking dynamic linked libraries (DLLs) or using one of four different methods of injecting code. You’ll also learn the fundamentals of dumping processes, libraries, and kernel modules (any portable executable [PE] files) from memory, including samples that are initially packed or compressed.</p></blockquote><p>本章进一步讲了一下Process在内存中的结构，也具体介绍了几种具体的检测恶意代码的方法</p><p>本章内容：</p><ul><li>了解进程内存中能提供该进程细节的信息</li><li>分析进程的堆，从内存取证的角度了解进程在什么情况下会将数据存在堆里</li><li>学习恶意软件如何通过创建新的环境变量存在于内存中</li><li>分析进程的输入输出handle, 从而分析是否被重定向</li><li>学习进程如何加载，放置DLL</li><li>从内存中提取PE文件用于逆向分析</li><li>检测代码植入</li></ul><h2 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h2><p>PEB 这个玩意的地址是在放在 _EPROCESS 的成员，包括了很多有关进程的东西，比如可执行文件的位置，进程的堆指针，对DLL的描述等等。</p><hr><p><strong>Attention</strong></p><p>PEB是存在于用户区域的，__EPROCESS中存的是指向PEB的指针</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310013642325.png" srcset="/img/loading.gif" alt="image-20200310013642325"></p><p>因为存在用户区，所以也容易被修改，所以可能需要VAD来验证。</p><hr><p>看一下具体的结构</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310013938977.png" srcset="/img/loading.gif" alt="image-20200310013938977"></p><ul><li>BeingDebugged：这个位挺关键的，这代表该进程是否正在被debug，有些malware是会开启debug来搞事情的，所以当这个位被置1但是没有合法的debuger在运行的时候，是会发出警告的。</li><li>ImageBaseAddress: 指出了.EXE被加载的位置，之后的procdump用到了这个值去找位置</li><li>Ldr: 指出有关DLL的信息的位置。</li><li>ProcessParameter: 指向程序参数结构，下面介绍</li><li>ProcessHeap: 指出进程堆的位置</li></ul><p>_RTL_PROCESS_PARAMETERS结构:</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310014735744.png" srcset="/img/loading.gif" alt="image-20200310014735744"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310014747335.png" srcset="/img/loading.gif" alt="image-20200310014747335"></p><p>前三个指出了对应的句柄</p><ul><li><p>ImagePathName: 指出了.exe文件在磁盘上的位置，比如C:\Windows\ System32\XXX</p></li><li><p>commondLine: 就是在我们在黑框框里面输入的那些，调用该进程的命令</p></li><li><p>Environment: 指向该进程的环境变量</p></li></ul><p>注意到，我们在PEB中的LDR是一个结构指针，指向了PEB_LDR_DATA，这个结构中存了三个链表的人口，链表中每个元素都是LDR_DATA_TABLE_ENTRY结构。结构描述了有关模块的情况，注意，这里的模块并不止于dll，而且也包括executable。</p><p>三条链:</p><ul><li>InLoadOrderModuleList：按照加载顺序排的一条链，因为可执行部分总是第一个加载所以总是放在第一个。</li><li>InMemoryOrderModuleList: 按照在内存中的分布排的链，因为ASLR所以不一定就是按加载顺序放。</li><li>InInitializationOrderModuleList: 这是按照DLL中的主函数被调用的顺序来排的，因为模块加载上来之后不一定是一加载就调主函数。</li></ul><p>关于这个链中的元素的结构:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310020242131.png" srcset="/img/loading.gif" alt="image-20200310020242131"></p><ul><li>DllBase：存的是加载的模块的基地址</li><li>EntryPoint: 存模块第一条运行的地址</li><li>LoadCount，指的是被加载的次数，就有点像系统文件打开表，打开一次加一次，之后全部关了才能卸下内存</li></ul><h2 id="进程的堆"><a href="#进程的堆" class="headerlink" title="进程的堆"></a>进程的堆</h2><p>一般来说，进程的输入输出的一些数据往往会存在于进程的堆中，所以如果我们要去查找一些输入输出的数据的时候我们需要找到堆的位置。</p><p>书中举了一个查找notepad++输入缓冲区中信息的例子。</p><p>因为这类信息一般存在堆中，所以要定位堆，直接用跟堆有关的插件(heap)即可，在给出的堆中找到其中标志有<strong>extra</strong>的块，其中可能有货，之后用volshell进入这个进程，用db看内存即可</p><hr><p><strong>Question:</strong>    </p><p>​    这个extra实际上是块中的一个标志位: HEAP_ENTRY_EXTRA_PRESENT 位于  _HEAP_ENTRY.Flags 中，至于为什么这个extra能说明问题，作者对于这个也很晕逼</p><blockquote><p>Regardless of the actual meaning of the “extra” flag (we’ve never found a good description) </p></blockquote><hr><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote><p>The variables are organized as multiple NULL-terminated strings, similar to a REG_MULTI_SZ value in the registry. If an attacker manipulates these variables, they can cause the target application to unexpectedly execute a malicious process. </p></blockquote><p>就是我们天天配的那个玩意，虽然我们往往只是改一下或者添加一下path，path是环境变量的一部分</p><p>一般来说环境变量有这些</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310025934803.png" srcset="/img/loading.gif" alt="image-20200310025934803"></p><p>对应到下面就是:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310025445269.png" srcset="/img/loading.gif" alt="image-20200310025445269"></p><p>以上是系统变量和用户变量，关于四种不同的环境变量的相关性质区别</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310025645271.png" srcset="/img/loading.gif" alt="image-20200310025645271"></p><p>而且一般来说，子进程是继承父进程的环境变量的。父进程也可以通过调用CreateProcess指定参数来创建新的环境变量</p><h3 id="攻击进程的环境变量"><a href="#攻击进程的环境变量" class="headerlink" title="攻击进程的环境变量"></a>攻击进程的环境变量</h3><h4 id="修改PATH或者PATHEXT"><a href="#修改PATH或者PATHEXT" class="headerlink" title="修改PATH或者PATHEXT"></a>修改PATH或者PATHEXT</h4><p>​    可以修改PATH或者PATHEXT这个比较好理解，就是修改PATH或者PATHEXT的顺序使得当当要调用的时候先调用了恶意的软件</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030447307.png" srcset="/img/loading.gif" alt="image-20200310030447307"></p><p>变成：</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030501147.png" srcset="/img/loading.gif" alt="image-20200310030501147"></p><p>这样就会先找.tmp下的文件，然后在这里放一个恶意软件就可以得到执行</p><p>同理对PATHEXT</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030548250.png" srcset="/img/loading.gif" alt="image-20200310030548250"></p><p>变成:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030621734.png" srcset="/img/loading.gif" alt="image-20200310030621734"></p><p>这样执行一个比如calc的文件，首先执行calc.zzz再执行cala.com, 实现攻击。</p><h4 id="用环境变量作为标记"><a href="#用环境变量作为标记" class="headerlink" title="用环境变量作为标记"></a>用环境变量作为标记</h4><p>很多时候恶意软件通过一些可以全局访问的变量标志自己在系统中的存在(为了不被友军误伤)，就比如Coreflood这个恶意软件，他的核心是一个DLL，但是每个Process只要装载一次，所以对每个加载过的process添加一个独特的string到他的环境变量中去，每次上载之前先看一下有没有先加入这个string，若加入了不上载了。</p><h2 id="标准句柄"><a href="#标准句柄" class="headerlink" title="标准句柄"></a>标准句柄</h2><p>这个标准句柄准确翻译应该是: 标准输入输出异常处理的句柄。</p><p>分析这个句柄是很有用的(就比如我们的实验分析shelly.exe), 因为很多恶意的软件在系统上留后门的方式是这样的:比如在目标主机上开启一个程序,然后这个程序一直在监听某个特定的端口，如果端口来了请求，就新建一个命令行进程交给请求的客户端，然后主机继续监听。</p><p>注意到，敌手可以发起这个请求然后获得这个cmd，然后对系统进行肆意妄为。(实验shelly.exe原理就是这个)</p><h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>DLL全称Dynamic Link libraries，其中包含执行部分和资源，可以被进程加载并在之后享有进程的所有资源: 进程，句柄等等。也因此容易被攻击者利用。</p><p>我们在分析DLL的时候要注意:</p><ul><li>之前的三条链，注意他有没有故意去隐藏自己</li><li>奇怪的加载地址比如:C:\Windows\ system32\sys\kernel32.dll, 或者从非NTFS区加载进来的</li><li>上下文，比如notepad++加载ws2_32.dll 就会比较可疑</li></ul><h3 id="DLL加载"><a href="#DLL加载" class="headerlink" title="DLL加载"></a>DLL加载</h3><ul><li>每个.exe有一个IAT(import address table)来加载需要的dll</li><li>每个dll也有他自己依赖的dll</li><li>runtime load：loadlibiary() 允许程序在运行时加载dll</li><li>代码植入，dll被强行加载到目标进程中去</li></ul><p>​    获取加载的dll，现在微软提供了一些API供使用，也有一些现成的工具来直接用，但需要注意的是，这些工具用的都是遍历loadlist。</p><p>​    所以我们有时要看其他两条链防止攻击者把加载的dll在loadlist中隐藏了</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310112347365.png" srcset="/img/loading.gif" alt="image-20200310112347365"></p><p>我们看一下dlllist遍历这个loadlist的结果</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310105316251.png" srcset="/img/loading.gif" alt="image-20200310105316251"></p><p>​    可以看到.exe先加载，之后是相应的dll加载，注意到loadcount，这个值我们之前提到是指loadlibrary 加载他的次数其中0xffff是指-1，在这里意思是用IAT加载而不是通过loadlibrary</p><p>​    </p><h3 id="检测未连接的DLL"><a href="#检测未连接的DLL" class="headerlink" title="检测未连接的DLL"></a>检测未连接的DLL</h3><p>之前提到了从一条链上解除的技术，对于这个我们可以用其他两条链来交叉验证，但是现在也有了解除三条链的技术，所以必须要有新的方法来找这些隐藏的dll。</p><ul><li>PE file scan: 通过扫描内存中的PE实例，找PE实例可以通过找PE的特殊开头:MZ,但是由于依然是在用户空间，既然malware可以修改list， 他也是可以修改开头的。</li><li>VAD cross-referencing: VAD中包含了该段内存中对应到的硬盘中的映射，比如该段内存的内容包含了哪个文件以及文件的full path。VAD位于内核，所以不能被轻易修改</li></ul><p>介绍一下VAD cross-reference的插件: ldrmudles,</p><p>工作原理:</p><ol><li>首先在VAD中找大节点(往往存mapfile，dll) with PAGE_EXECUTE_WRITECOPY protections, a VadImageMap type, and the Image control flag set.</li><li>然后比较这个VAD节点中的address和在用户内存扫描得出的DllBase(位于_LDR_DATA_TABLE_ENTRY)</li><li>出现在VAD中但是不在扫描结果中的很有可能就是被hide了</li></ol><h2 id="内存中的PE文件"><a href="#内存中的PE文件" class="headerlink" title="内存中的PE文件"></a>内存中的PE文件</h2><p>书中首先指出很难在内存中dump出一份跟执行时一模一样的PE文件，但是提取出来的信息足够分析使用。</p><p>这里提取PE是因为很多PE进行pack，但是放在内存上就没有壳保护了，于是在内存取出来到硬盘上之后可以用于逆向分析</p><p>然后文中还提到了为什么不可以用内存中PE的hash跟硬盘上的hash进行比较得出是否被修改，有很多原因:</p><ul><li>IAT是被添加的(loadlibrary的调用)</li><li>一些section不一定是每次都加载到内存上去，比如.rsrc, 只有在访问的时候才加上去</li><li>存在松弛空间：松弛空间是指，一个section在内存中不一定是正好是一页的整数倍，所以为了对齐(保护方式是按页为单位的，所以不能一个页一部分可写另一部分标记位可写可读可执行)，内存中的PE相对于硬盘是存在很多松弛空间的。</li></ul><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310131908736.png" srcset="/img/loading.gif" alt="image-20200310131908736"></p><h3 id="提取内存中PE的步骤"><a href="#提取内存中PE的步骤" class="headerlink" title="提取内存中PE的步骤"></a>提取内存中PE的步骤</h3><p>我们拿volshell下步骤作为例子</p><p><strong>Step 1.</strong> </p><p>首先用volshell attach到一个指定的进程上，获取该进程的实例，并从中得到PEB，从PEB得到ImageBaseAddress， 康康DOS头</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132756815.png" srcset="/img/loading.gif" alt="image-20200310132756815"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132822860.png" srcset="/img/loading.gif" alt="image-20200310132822860"></p><p><strong>Step 2.</strong></p><p>可以看到标准的签名MZ(4d5a), 然后通过这个头找到NT头</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132931276.png" srcset="/img/loading.gif" alt="image-20200310132931276"></p><p><strong>Step 3.</strong></p><p>得到NT头之后，就豁然开朗了，从中得到各个section的偏移</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133128459.png" srcset="/img/loading.gif" alt="image-20200310133128459"></p><p><strong>Step 4.</strong></p><p>然后根据偏移把各个section写到硬盘上去即可</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133224747.png" srcset="/img/loading.gif" alt="image-20200310133224747"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133232861.png" srcset="/img/loading.gif" alt="image-20200310133232861"></p><p>就得到了dumped.exe</p><h3 id="现有写好的PE提取插件"><a href="#现有写好的PE提取插件" class="headerlink" title="现有写好的PE提取插件"></a>现有写好的PE提取插件</h3><p>这些插件都是基于上面那个原理</p><ul><li><p>procdump: 有两个选项 –pid(通过上面的方法) 或者 –offset(通过_EPROCESS, 这个可以找到不在list中的进程)</p></li><li><p>dlldump: 这个跟procdump的类似但是是提取dll的</p></li><li><p>moddump: 读取kernel module</p><p>详见P242</p></li></ul><p>所有上面三个都需要提供 –dump-dir参数(写到哪里去) –memory(指定是否需要松弛空间)</p><p>例子:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135136944.png" srcset="/img/loading.gif" alt="image-20200310135136944">  </p><p>这里文件的命名都是excutable.PID.exe</p><p>下面这个例子给出了不在pslist中的进程怎么提出来（其中的地址是通过_EPROCESS对象中读出来的):</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135638418.png" srcset="/img/loading.gif" alt="image-20200310135638418"></p><p>下面给出提取dll的例子，这里指定了提出名字中含有crypt的dll。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135543480.png" srcset="/img/loading.gif" alt="image-20200310135543480"></p><p>但是对于一些注入或者隐藏的dll，你没法正常读出来因为不知道名字也不在list上，所以通过得到这个PE的位置然后往后扫描</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135851589.png" srcset="/img/loading.gif" alt="image-20200310135851589"></p><hr><p><strong>Attention!</strong></p><p>注意到，不管是上面的插件也好或是直接遍历的方法也好，若是MZ被修改或是section的位置被修改都会导致出问题。我们可以通过使用vaddump把该进程的相关内存先提出来之后对这个内存做manual fix-up 然后再用IDA去分析</p><hr><h2 id="打包与压缩问题"><a href="#打包与压缩问题" class="headerlink" title="打包与压缩问题"></a>打包与压缩问题</h2><p>为了克服打包和压缩带来的混淆，往往是上载到内存用自带的解压程序解压之后再来分析</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310164832596.png" srcset="/img/loading.gif" alt="image-20200310164832596"></p><p>所以一般的套路是:</p><p>运行在虚拟机下运行：</p><ol><li>拍一个内存快照</li><li>使用procdump</li><li>使用string cat在内存中找字符串</li></ol><hr><p><strong>Question</strong></p><blockquote><p>The layers of obfuscation introduced by packed or compressed binaries are often removed when they load into memory. In almost all cases, before executing the main payload, a self-modifying program decompresses in place, or moves to another address and then decompresses.</p></blockquote><p>这个self-modifying程序是指什么呢?</p><hr><h2 id="Code-injection"><a href="#Code-injection" class="headerlink" title="Code injection"></a>Code injection</h2><p>文中把代码植入分为以下四种</p><ol><li>Remote DLL injection: 恶意进程强制目标进程去通过LoadLibrary从磁盘上加载DLL，但这种注入的前提是DLL必须在磁盘上。</li><li>Remote code injection: 恶意进程直接传代码块(shellcode)给目标进程</li><li>Reflective DLL injection: 恶意进程向目标进程内存空间中写入dll，这个dll自己初始化不需要windows的loader</li><li>Hollow process injection: 恶意进程首先启动一个新的合法的进程实例然后使其suspend，在这个进程恢复之前，他的内存空间是被挖空的，由恶意代码使用。</li></ol><p>下面介绍一下上面提到的几种注入:</p><p>以下进程A为恶意进程，B为目标进程</p><h3 id="远程DLL注入"><a href="#远程DLL注入" class="headerlink" title="远程DLL注入"></a>远程DLL注入</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>进程A将自己设置为debug程序(使能SE_DEBUG_PRIVILEGE)，这使得他可以对其他进程的内存进行读写就好像一个debugger</li><li>进程A通过OpenProcess打开一个进程B 的句柄, 打开的时候请求PROCESS_CREATE_THREAD, PROCESS_VM_OPERATION, PROCESS_VM_WRITE.</li></ol><hr><p>​        注: OpenProcess是打开一个现有的进程，返回其句柄，常用于进程之间的同步</p><hr><ol start="3"><li>进程A通过VirtualAllocEx在B的内存中开辟页，页的保护级别设置为PAGE_READWRITE.</li><li>A向B传输一个string.txt（指出dll在硬盘上的位置），这个string放在之前一步开的空间里</li><li>A通过CreateRemoteThread在B中创建一个新的线程来执行LoadLibrary进而加载在前一步中传过来的dll位置</li><li>直到这一步，注入已经完成了，A把在第3步中开辟的空间free掉</li><li>A调用closeHandle清理现场跑路</li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>对于这样一种注入，我们很难分辨出合理加入的dll和被注入的dll，因为不管从哪里看他们可能都是identical的，但总的来说，有这么两种方法来区分他们</p><ol><li>如果注入的dll尝试把自己隐藏起来(比如把自己从链上摘下)，这样就可以根据之前的两种方法来断定他是不是被注入的</li><li>如果被注入dll是被pack的，他需要开辟一块新空间，把解压代码copy过去执行进而执行</li></ol><p><em>这么说来，不作死就好好呆在那里反而最安全</em></p><h3 id="远程代码注入"><a href="#远程代码注入" class="headerlink" title="远程代码注入"></a>远程代码注入</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>前两步跟DLL一样</p><ol start="3"><li>A进程在B进程中分配一片PAGE_EXECUTE_READWRITE的内存，这使得A可以再这里胡作非为(可读可写可执行)</li><li>A传一个代码块给B</li><li>A在B中开一个新的线程去执行刚传的代码块</li></ol><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>介绍一下<strong>malfind</strong>插件！</p><p>先介绍一下malfind 判断是否为inject的标准(同时满足):</p><ul><li>有一片可读可写可执行的内存</li><li>这片内存是private的</li><li>所有的内存都是commit的</li><li>这篇内存存在CPU指令或者PE头</li></ul><hr><p><strong>Question:</strong></p><p>​    正常的代码区域不满足这些条件?</p><hr><p>我们看一下几个例子加深理解:</p><h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310180746809.png" srcset="/img/loading.gif" alt="image-20200310180746809"></p><p>这是malfind找到的一个片段但是我们不能判断他是不是真的注入代码，因为有些时候合理的代码也会满足这类条件。这里是找到了一个PE头</p><h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h5><p>接下来的并没有PE头，因为注入的是一块shellcode</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181049499.png" srcset="/img/loading.gif" alt="image-20200310181049499"></p><p>这个很可能是一块注入代码，因为其汇编语言在这里是make sense的，比如跳转地址合理</p><p>MOC EDI, EDI</p><p>PUSH EBP</p><p>代表即将函数调用</p><h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h5><p>再看一个正常代码但是被错判的:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181319070.png" srcset="/img/loading.gif" alt="image-20200310181319070"></p><p>因为符合malfind的标准所以被找出来了，为什么说是错判呢，可以看到有Enter 没有 leave， 而且JNO之前没有比较，所以这是无意义的代码片段</p><h5 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h5><p>下面看一个恶意代码伪装自己的例子</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181603923.png" srcset="/img/loading.gif" alt="image-20200310181603923"></p><p>可以看到这里全是0，一眨眼以为是找错了，但是我们看下一页的时候就会发现端倪</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181720248.png" srcset="/img/loading.gif" alt="image-20200310181720248"></p><p>这边就是恶意代码的主函数了。</p><hr><p><strong>Question：</strong><br>书上说这是函数开始，为啥没有call或者JMP啊，是我汇编没学好么 ？。？</p><hr><h4 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h4><p>使用malfind只是缩小范围，然后还要根据自己的经(xia)验(cai)和汇编只是来确定</p><h3 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h3><p>这是前两者的杂交，A向B传递了一个dll</p><p>他有两个优势:</p><ul><li>不需要提前在磁盘里写好，直接通过连接就可以把DLL送入加载区域</li><li>不要调用loadlibrary，也可以避免出现在那三条链中</li></ul><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310182809527.png" srcset="/img/loading.gif" alt="image-20200310182809527"></p><p>可以看得出来是满足malfind的查询条件的。所以也可以用malfind查询</p><h3 id="挖空注入"><a href="#挖空注入" class="headerlink" title="挖空注入"></a>挖空注入</h3><p>之前的三种方法都是在目标进程中开一个新线程来执行恶意代码，但是目标进程仍然是在执行的。这个方法是直接创建一个新的合法进程，在执行之前把其中合法进程的PE占的空间全部free掉，放入恶意代码，然后开始执行但是其他数据结构(PEB)是这个合法进程的，所以依旧会被认作这个合法进程</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310183531474.png" srcset="/img/loading.gif" alt="image-20200310183531474"></p><h4 id="如何挖空进程"><a href="#如何挖空进程" class="headerlink" title="如何挖空进程"></a>如何挖空进程</h4><ol><li>开启一个合法的新进程比如: C:\windows\system32\ lsass.exe, 但是把他的第一个线程给suspend，此时，PEB的相关数据都是lsass.exe</li><li>获取恶意代码，可以从硬盘上也可以从缓冲区中等等</li><li>找到lsass.exe的ImageBase，然后free掉所有的section。此时DLL,堆栈，句柄都是完好的，只不过PE被挖空了</li><li>在lasass.exe中开辟一个新的内存段(可读可写可执行)，然后返回imagebase(可以跟之前一样也可以不一样)</li><li>把恶意代码的PE header 放到这篇内存中去。</li><li>根据header中的section指示加载各个section</li><li>把那个suspend 的线程的开始位置指向刚加载的section中去(AddressOfEntryPoint)</li><li>开始执行, 在lsass.exe的容器中</li></ol><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>我们从PEB上是看不出任何区别的</p><p>注意到他有重新分配内存所以我们应该从VAD的角度来考虑，查看VAD的相关信息，所以当看到有多个相同的进程的时候，比较他们的VAD信息尽管PEB中含的是合法进程的数据，但是VAD真实记录了所有发生在这段内存上的事情！详见P260(就是sample007.mem的解析)</p><p>所以我们可以看一下ldrmodules和VAD中的记录区别</p><hr><p><strong>Question:</strong></p><blockquote><p>Because lsass.exe was unmapped, a name is no longer associated with the region at 0x01000000. But calling NtUnmapViewOfSection (step 3) doesn’t cause the PEB to lose its metadata, so those structures still have a record of the original mapping in the load order and memory order lists P261</p></blockquote><p>没懂这段</p><hr><h2 id="处理dump-出来的内存文件"><a href="#处理dump-出来的内存文件" class="headerlink" title="处理dump 出来的内存文件"></a>处理dump 出来的内存文件</h2><p>​    就是说了下很多时候把dump出来的文件是要处理一下才能放到一些逆向软件中去的，当不清楚dump出的内存的时候，建议用一下impscan得到该文件的一些信息，这里书中也就是笼统的讲了一下。</p>]]></content>
    
    
    <categories>
      
      <category>Memory Forensics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProcessMemoryInternals</title>
    <link href="/2020/03/08/ProcessMemoryInternals/"/>
    <url>/2020/03/08/ProcessMemoryInternals/</url>
    
    <content type="html"><![CDATA[<h1 id="Chapter-7-Process-Memory-Internals"><a href="#Chapter-7-Process-Memory-Internals" class="headerlink" title="Chapter 7 Process Memory  Internals"></a>Chapter 7 Process Memory  Internals</h1><p>This chapter gives the details about the  process Memory.</p><p>First, we start with</p><h2 id="What-is-in-the-Process-memory"><a href="#What-is-in-the-Process-memory" class="headerlink" title="What is in the Process memory"></a>What is in the Process memory</h2><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200308222601149.png" srcset="/img/loading.gif" alt="image-20200308222601149"></p><p>Actually, Linux has the same component except the DLL.</p><ul><li><p><em>Mapped files and application</em>:  This is the place where the process store data from the disk ( like read(“1.txt”)）</p></li><li><p><em>PEB</em>:  The process’s environment is stored here</p></li></ul><hr><p>We may notice the MmHighestUserAddress, this address vary between different operating  systems.</p><hr><h3 id="API-that-are-used-to-allocate-the-memory"><a href="#API-that-are-used-to-allocate-the-memory" class="headerlink" title="API that are used to allocate the memory"></a>API that are used to allocate the memory</h3><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200308224939441.png" srcset="/img/loading.gif" alt="image-20200308224939441"></p><p>We see from the above picture, no matter heapAlloc or Non-heapAlloc APIs root in the native function NtAllocateVitualMemory(). </p><p><strong>Attention：</strong></p><blockquote><p>Only a few of the APIs allow the programmer full control over permissions for the allocated memory.</p></blockquote><p>  permission includes: readable, writable, executable</p><p>One important API is VirtualAllocEx, this is the only API that allows a process allocate memory for another process, thus it is often used by malwares to allocate memory for the shellcode.</p><p><strong>Question:</strong></p><blockquote><p>These two virtual allocation functions are also the only ones that allow the caller to reserve memory (that is, set it aside) before committing it. This allows applications to “save” a large region of virtually contiguous memory for later use, without tying up the underlying physical pages in the meantime P193</p></blockquote><p>what is reserve memory and commit memory？</p><h3 id="Enumerating-Process-Memory"><a href="#Enumerating-Process-Memory" class="headerlink" title="Enumerating Process Memory"></a>Enumerating Process Memory</h3><p>主要讲了一下跟进程相关的内存中的重要结构</p><ul><li>页表: 这个大家都懂，位于UVPT，用于虚拟地址和物理地址转换</li><li>VAD: 这是用于对虚拟页的描述的， 比如一个进程申请了10个页，一个页4K，那么一个VAD就会被创建来描述这40K，如果其中有mapfile的话，VAD也是会有记录的</li><li>工作集: 这是最近被使用过的页的集合</li><li>PFN database: 这跟上面的不同，这是记录每一个物理页状态的database。这个database是一个存放在<strong>KDEBUGGER</strong>_DATA64.MmPfnDatabase中的数组</li></ul><p>接下来就来详细介绍一下页表和VAD</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>页表的作用就不在里说了，这里主要讲一下关于页表的volatility的插件</p><p>memdump， memmap</p><hr><p>这两个插件可以挖掘出指定进程牵扯到(accessible)的页表，这里的accessible也可能涉及到内核页，但是并不代表该进程可以直接使用该页，而是出于他使用了系统掉用的原因把该页视为accessible。</p><hr><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309005215740.png" srcset="/img/loading.gif" alt="image-20200309005215740"></p><p>这是memdump能拿到的指定进程牵涉到的页，可以看到其中有很多空白，这是指那些被换掉的页</p><p>看一个实际的例子</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309005450013.png" srcset="/img/loading.gif" alt="image-20200309005450013"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309005529399.png" srcset="/img/loading.gif" alt="image-20200309005529399"></p><p>可以看到</p><ul><li>虚拟地址也不是连续的，解释为可能被换了，也有可能没有commit</li><li>有些大小是0x20000的，书上的解释说这个是Page Size Entry pages</li></ul><hr><p>这个PSE在第三章也有提到，但是不是很清楚原理。</p><p>PSE:</p><hr><p>再注意到最右边的DumpfileOffset，因为一段内存可能很大比如8G，但是一个程序不可能全部都用到，所以跟他相关的页其实不多，但是他也有可能不连续的使用比如在1G,6G的位置分别用了一页，但是我们没必要把1G到6G无关的内存全部导出来分析(相当于导出文件把中间的5G压缩了)，所以这个值是指对应的页在导出文件的偏移位置。</p><p>到现在为止，其实你已经拿到有关的页了，但是你还不知道这些页对应到的是什么，比如哪些页是对应mapfile，哪些是对应dll这样，所以接下来有请第二位主角VAD</p><h2 id="VAD"><a href="#VAD" class="headerlink" title="VAD"></a>VAD</h2><p>VAD的全称是virtual address description</p><p>VAD实际上是一个树状结构，说的清楚一点，就有点像一个线段树，每一个节点都是一段内存<strong>，但是！</strong>他不是线段树！！！是一个平衡二叉树，毕竟为了更加快速地查找修改。</p><p>VAD的每一个节点存了这样一些信息:</p><ul><li>这段内存有没有mapfile</li><li>这段内存有多少页</li><li>这段内存的初始保护状态(写，读，执行)</li><li>其他flag值</li></ul><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309011634584.png" srcset="/img/loading.gif" alt="image-20200309011634584"></p><p>上面的图是可以用插件画出来的！-vadtree 插件</p><h3 id="VAD结构"><a href="#VAD结构" class="headerlink" title="VAD结构"></a>VAD结构</h3><p>在进程的_EPROCESS的结构体中，其中有个叫做VadRoot的指针，指向这个VAD的root。</p><p>VAD的节点中当然还要存左右孩子指针。</p><p>分配内存的函数类型和其参数决定了这段内存的性质，也就决定了VAD中的一些信息</p><p>对于不同的系统来说，VAD的节点可能有所不同，但是差别不大，都是分为_MMVAD_SHORT, _MMVAD, _MMVAD_LONG。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309030653676.png" srcset="/img/loading.gif" alt="image-20200309030653676"></p><p>我们先看一下root节点的结构</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309012707661.png" srcset="/img/loading.gif" alt="image-20200309012707661"></p><p>可以看到其中指向的头节点，其类型为_MMADDRESS_NODE</p><p>我们再具体看下VAD 的结构</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309012720197.png" srcset="/img/loading.gif" alt="image-20200309012720197"></p><p>Vpn的意思是Virtual Page Number的意思，用这个开始的页号和结束的页号，我们可以得到整个占用的内存大小</p><p>这个node结构其实不是真正的node结构，是node中基本最基本信息，就像我们之前看到的表，是有三种不同node的</p><p>我们看一下:</p><p>short node</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309013820722.png" srcset="/img/loading.gif" alt="image-20200309013820722"></p><p>regular node</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309013834554.png" srcset="/img/loading.gif" alt="image-20200309013834554"></p><p>large node</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309013857119.png" srcset="/img/loading.gif" alt="image-20200309013857119"></p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309013903634.png" srcset="/img/loading.gif" alt="image-20200309013903634"></p><p>我们可以注意到，跟普通和大节点不一样的是</p><p>小节点没有那个mapfile和dll记录，所以如果要找mapfile或者dll的话不用去小节点里面找</p><p>反过来想，因为小页面就是存可执行代码的多，所以我们在找shellcode的时候，就不会去large或者regular中找，而是到小的里面找(比如下面的VadS或者VadF)</p><p><strong>我们是怎么使用Volatility来区分各个节点的呢?</strong></p><p>我们会发现一个很神奇的事情，这些结构的第一个成员的偏移竟然是负的！！！实际上这是在这个结构之前的PoolTag，来指定这个VAD的类型！按照书上这么说的话，这个VAD应该也是一种object！</p><p>Tag与Node类型对应表</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309015945750.png" srcset="/img/loading.gif" alt="image-20200309015945750"></p><h3 id="VAD-flag"><a href="#VAD-flag" class="headerlink" title="VAD flag"></a>VAD flag</h3><p>flag 是一个在node中的8字节联合</p><p>[0，51)代表了commitCharge， </p><p>[51,52)代表了Nochange</p><p>[52,55)代表了Vad_type</p><p>[55,56)代表了MemCommit</p><p>[56-61)位代表的是Protection</p><p>[61,63)代表了Spare</p><p>[63.64)代表了PrivateMemory</p><p>分别来看下这CommitCharge和Protection</p><h4 id="CommitCharge"><a href="#CommitCharge" class="headerlink" title="CommitCharge"></a>CommitCharge</h4><p>这个代表了在该VAD代表的内存范围中，有多少是被该进程commit的。这个成员跟MemCommit是有点类似的。</p><blockquote><p>MemCommit tells you whether the memory was committed when the virtual allocation API (NtAllocateVirtualMemory) was first called</p></blockquote><p>但是对于书中的这一段话我不是很理解</p><blockquote><p>The reason we care about this field is because historically when code injecting malware sets up the target process’ address space to receive the malicious code, it commits all pages up front—it doesn’t reserve them and then go back and commit them later (although it very well could). Thus, you can use these additional characteristics to help identify injected memory regions.</p></blockquote><h4 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h4><p>这个很好理解，就是各个位分开表示该段内存的之前权限。可以用来帮助判断一段未知内存的大概作用。</p><p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200309022822680.png" srcset="/img/loading.gif" alt="image-20200309022822680"></p><p><strong>Attention！</strong></p><hr><p>这个保护级别是指刚开始申请的的保护级别，比如一段内存第一次申请的时候是不可执行，这个protection字段就就设置为不可执行，但是第二次申请其中某些页为可执行该VAD中的protection位依旧是保持不可执行的值，但是这段内存中重新被申请的页却是可执行的，因为一开始申请这个VAD的时候，是针对这个范围的所有的页，但是权限这个东西却是以页为单位的。所以其中的页被再申请之后真正的protection变了也不足为奇。</p><hr><h4 id="Private-memory"><a href="#Private-memory" class="headerlink" title="Private memory"></a>Private memory</h4><p>指的是不能被分享以及不能被继承的memory。</p><p>因为mapfile和DLL一般是被share的，所以如果该位被置1了，则很有可能就不是这两种而更有可能是堆栈之类的。</p><blockquote><p>A process’ heaps, stacks, and ranges allocated with VirtualAlloc or VirtualAllocEx are usually marked as private. As previously described, because VirtualAllocEx is used to allocate memory in a remote process, the PrivateMemory member is yet another factor you can look at when looking for injected shell code.</p></blockquote><h3 id="跟VAD有关的插件"><a href="#跟VAD有关的插件" class="headerlink" title="跟VAD有关的插件"></a>跟VAD有关的插件</h3><h4 id="vadinfo"><a href="#vadinfo" class="headerlink" title="vadinfo"></a>vadinfo</h4><p>这个是将有关的全部vad node全部信息打出来</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309024135250.png" srcset="/img/loading.gif" alt="image-20200309024135250"></p><h4 id="vaddump"><a href="#vaddump" class="headerlink" title="vaddump"></a>vaddump</h4><p>将VAD树中的所有内存找出来存到一个文件中去，跟之前的memmap不一样，那个是有压缩的，这个是用0填充了。</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309024646347.png" srcset="/img/loading.gif" alt="image-20200309024646347"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200309024738938.png" srcset="/img/loading.gif" alt="image-20200309024738938"></p><h4 id="vadtree"><a href="#vadtree" class="headerlink" title="vadtree"></a>vadtree</h4><p>这个之前介绍过了，可以把树画出来</p><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><h3 id="查找内存中的用户名和密码"><a href="#查找内存中的用户名和密码" class="headerlink" title="查找内存中的用户名和密码"></a>查找内存中的用户名和密码</h3><p>这里介绍到了一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search_ process_memory()</span><br></pre></td></tr></table></figure><p>这是在遍历树的时候到对应的范围查找对应的pattern，找到则返回位置，在这个例子中就是查找&amp;password，&amp;username(浏览器POST的参数)</p><h3 id="Yara插件的应用"><a href="#Yara插件的应用" class="headerlink" title="Yara插件的应用"></a>Yara插件的应用</h3><p>这个插件很强，可以在很多数据中匹配pattern，比如文件或者memory dump。</p><p>因为我们很多直接的搜索是在物理内存上，当数据跨页了就很难找到了，但是这个插件解决了这个问题。而且可以一次匹配多个rule</p><h3 id="在内存中查找宙斯密码的密钥"><a href="#在内存中查找宙斯密码的密钥" class="headerlink" title="在内存中查找宙斯密码的密钥"></a>在内存中查找宙斯密码的密钥</h3><p>这个过程有点复杂，首先逆向要看他的函数调用关系，确定一些必要的指令片段之后用这些指令片段去匹配。</p>]]></content>
    
    
    <categories>
      
      <category>Memory Forensics</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bayes</title>
    <link href="/2020/03/02/Naive%20Bayes%20&amp;%20Bayes/"/>
    <url>/2020/03/02/Naive%20Bayes%20&amp;%20Bayes/</url>
    
    <content type="html"><![CDATA[<h1 id="Naive-Bayes-amp-Bayes"><a href="#Naive-Bayes-amp-Bayes" class="headerlink" title="Naive Bayes &amp; Bayes"></a>Naive Bayes &amp; Bayes</h1><p>The difference between naive Bayes and Bayes is that naive Bayes assumes that the value of the input feature is independent distributed.</p><p>This a quite strong assumption, and that’s why it is named as naive Bayes.</p><h4 id="Notation-explanation-some-notations-that-will-be-used-in-the-following-blog"><a href="#Notation-explanation-some-notations-that-will-be-used-in-the-following-blog" class="headerlink" title="Notation explanation(some notations that will be used in the following blog)"></a>Notation explanation(some notations that will be used in the following blog)</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216005215134.png" srcset="/img/loading.gif" alt="image-20200216005215134"> means that the j^th feature of the i^th  input.</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216005416391.png" srcset="/img/loading.gif" alt="image-20200216005416391"> means the l^th possible value of the  j^th feature</p><h3 id="Learning-Process"><a href="#Learning-Process" class="headerlink" title="Learning Process"></a>Learning Process</h3><p>The learning process for the Bayes is to ‘learn’ the prior probability and the condition probability.</p><p><strong><em>prior</em></strong> <strong><em>probability</em></strong>:  probability of a certain deed to happen</p><p>Say, something like this:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216004257349.png" srcset="/img/loading.gif" alt="image-20200216004257349"></p><p>Condition probability:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216004338052.png" srcset="/img/loading.gif" alt="image-20200216004338052"></p><p>Because the naive Bayes assume that all the feature of one input are independent, so the above formula can be delivered in another way:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216004536707.png" srcset="/img/loading.gif" alt="image-20200216004536707"></p><p>After ‘learn’  the above parameter, then we begin the classification process</p><h3 id="Classification-Process"><a href="#Classification-Process" class="headerlink" title="Classification Process"></a>Classification Process</h3><p>The aim of Bayes model is to classify the input samples into certain categories.</p><p>which means:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216010800035.png" srcset="/img/loading.gif" alt="image-20200216010800035"></p><p>Intuitively, for all the probability we derive from the formula below, we choose the class which get the max value as the output of x. (Note that the condition probability and the prior probability have been ‘learned’)</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216011137636.png" srcset="/img/loading.gif" alt="image-20200216011137636"></p><p>And according to the basic assumption of the naive Bayes model the formula can also be written in this way:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216011427823.png" srcset="/img/loading.gif" alt="image-20200216011427823"></p><p>Then we choose the class for x:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216011530347.png" srcset="/img/loading.gif" alt="image-20200216011530347"></p><h3 id="How-to-‘learn’-the-parameter"><a href="#How-to-‘learn’-the-parameter" class="headerlink" title="How to ‘learn’ the parameter?"></a>How to ‘learn’ the parameter?</h3><p>We use the MLE (Maximum Likelihood Estimate)</p><p>Because the input and the output are discrete. So we can’t use the  derivative here. </p><p>I leave out the proof  of the following formulas here, those who are interested in that can try it yourself. And I will explain the following formulas in a simpler way</p><p>For the prior probability, we simply count the time of the class  appear in the training dataset, because using this method the parameter will fit the current dataset well. </p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216012308925.png" srcset="/img/loading.gif" alt="image-20200216012308925"></p><p>And the same thing for the condition probability</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216012333606.png" srcset="/img/loading.gif" alt="image-20200216012333606"></p><p>This learning process is quite simple as you see above. It’s funny to call it a learning process., so I add quotation marks to the word learn. XD</p><h3 id="Bayes-model"><a href="#Bayes-model" class="headerlink" title="Bayes model"></a>Bayes model</h3><p>It is easy to for us to notice a problem from the above method that we perfunctorily assume that classes that haven’t appear in the dataset have the zero probability to happen!</p><p> Therefore we introduce the Laplace Smoothing:</p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216014417115.png" srcset="/img/loading.gif" alt="image-20200216014417115"></p><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200216014427826.png" srcset="/img/loading.gif" alt="image-20200216014427826"></p><p>In these two equations, for those classes that haven’t appear in the dataset, the probability will  not be zero.   </p>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Math</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
