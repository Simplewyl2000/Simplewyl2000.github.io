<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>Hunting Malware - Simple</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Simple</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  Tuesday, March 10th 2020, 1:10 am
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    4.9k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      17 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          
          <div class="markdown-body">
            <h1 id="Hunting-Malware-in-Process-Memory"><a href="#Hunting-Malware-in-Process-Memory" class="headerlink" title="Hunting Malware in Process Memory"></a>Hunting Malware in Process Memory</h1><blockquote>
<p>The previous chapter introduced you to process memory internals and set the foundations for you to deep dive into analysis. Now you’ll see some specific examples of how you can detect malware that hides in process memory by unlinking dynamic linked libraries (DLLs) or using one of four different methods of injecting code. You’ll also learn the fundamentals of dumping processes, libraries, and kernel modules (any portable executable [PE] files) from memory, including samples that are initially packed or compressed.</p>
</blockquote>
<p>本章进一步讲了一下Process在内存中的结构，也具体介绍了几种具体的检测恶意代码的方法</p>
<p>本章内容：</p>
<ul>
<li>了解进程内存中能提供该进程细节的信息</li>
<li>分析进程的堆，从内存取证的角度了解进程在什么情况下会将数据存在堆里</li>
<li>学习恶意软件如何通过创建新的环境变量存在于内存中</li>
<li>分析进程的输入输出handle, 从而分析是否被重定向</li>
<li>学习进程如何加载，放置DLL</li>
<li>从内存中提取PE文件用于逆向分析</li>
<li>检测代码植入</li>
</ul>
<h2 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h2><p>PEB 这个玩意的地址是在放在 _EPROCESS 的成员，包括了很多有关进程的东西，比如可执行文件的位置，进程的堆指针，对DLL的描述等等。</p>
<hr>
<p><strong>Attention</strong></p>
<p>PEB是存在于用户区域的，__EPROCESS中存的是指向PEB的指针</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310013642325.png" srcset="/img/loading.gif" alt="image-20200310013642325"></p>
<p>因为存在用户区，所以也容易被修改，所以可能需要VAD来验证。</p>
<hr>
<p>看一下具体的结构</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310013938977.png" srcset="/img/loading.gif" alt="image-20200310013938977"></p>
<ul>
<li>BeingDebugged：这个位挺关键的，这代表该进程是否正在被debug，有些malware是会开启debug来搞事情的，所以当这个位被置1但是没有合法的debuger在运行的时候，是会发出警告的。</li>
<li>ImageBaseAddress: 指出了.EXE被加载的位置，之后的procdump用到了这个值去找位置</li>
<li>Ldr: 指出有关DLL的信息的位置。</li>
<li>ProcessParameter: 指向程序参数结构，下面介绍</li>
<li>ProcessHeap: 指出进程堆的位置</li>
</ul>
<p>_RTL_PROCESS_PARAMETERS结构:</p>
<p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310014735744.png" srcset="/img/loading.gif" alt="image-20200310014735744"></p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310014747335.png" srcset="/img/loading.gif" alt="image-20200310014747335"></p>
<p>前三个指出了对应的句柄</p>
<ul>
<li><p>ImagePathName: 指出了.exe文件在磁盘上的位置，比如C:\Windows\ System32\XXX</p>
</li>
<li><p>commondLine: 就是在我们在黑框框里面输入的那些，调用该进程的命令</p>
</li>
<li><p>Environment: 指向该进程的环境变量</p>
</li>
</ul>
<p>注意到，我们在PEB中的LDR是一个结构指针，指向了PEB_LDR_DATA，这个结构中存了三个链表的人口，链表中每个元素都是LDR_DATA_TABLE_ENTRY结构。结构描述了有关模块的情况，注意，这里的模块并不止于dll，而且也包括executable。</p>
<p>三条链:</p>
<ul>
<li>InLoadOrderModuleList：按照加载顺序排的一条链，因为可执行部分总是第一个加载所以总是放在第一个。</li>
<li>InMemoryOrderModuleList: 按照在内存中的分布排的链，因为ASLR所以不一定就是按加载顺序放。</li>
<li>InInitializationOrderModuleList: 这是按照DLL中的主函数被调用的顺序来排的，因为模块加载上来之后不一定是一加载就调主函数。</li>
</ul>
<p>关于这个链中的元素的结构:</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310020242131.png" srcset="/img/loading.gif" alt="image-20200310020242131"></p>
<ul>
<li>DllBase：存的是加载的模块的基地址</li>
<li>EntryPoint: 存模块第一条运行的地址</li>
<li>LoadCount，指的是被加载的次数，就有点像系统文件打开表，打开一次加一次，之后全部关了才能卸下内存</li>
</ul>
<h2 id="进程的堆"><a href="#进程的堆" class="headerlink" title="进程的堆"></a>进程的堆</h2><p>一般来说，进程的输入输出的一些数据往往会存在于进程的堆中，所以如果我们要去查找一些输入输出的数据的时候我们需要找到堆的位置。</p>
<p>书中举了一个查找notepad++输入缓冲区中信息的例子。</p>
<p>因为这类信息一般存在堆中，所以要定位堆，直接用跟堆有关的插件(heap)即可，在给出的堆中找到其中标志有<strong>extra</strong>的块，其中可能有货，之后用volshell进入这个进程，用db看内存即可</p>
<hr>
<p><strong>Question:</strong>    </p>
<p>​    这个extra实际上是块中的一个标志位: HEAP_ENTRY_EXTRA_PRESENT 位于  _HEAP_ENTRY.Flags 中，至于为什么这个extra能说明问题，作者对于这个也很晕逼</p>
<blockquote>
<p>Regardless of the actual meaning of the “extra” flag (we’ve never found a good description) </p>
</blockquote>
<hr>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote>
<p>The variables are organized as multiple NULL-terminated strings, similar to a REG_MULTI_SZ value in the registry. If an attacker manipulates these variables, they can cause the target application to unexpectedly execute a malicious process. </p>
</blockquote>
<p>就是我们天天配的那个玩意，虽然我们往往只是改一下或者添加一下path，path是环境变量的一部分</p>
<p>一般来说环境变量有这些</p>
<p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310025934803.png" srcset="/img/loading.gif" alt="image-20200310025934803"></p>
<p>对应到下面就是:</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310025445269.png" srcset="/img/loading.gif" alt="image-20200310025445269"></p>
<p>以上是系统变量和用户变量，关于四种不同的环境变量的相关性质区别</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310025645271.png" srcset="/img/loading.gif" alt="image-20200310025645271"></p>
<p>而且一般来说，子进程是继承父进程的环境变量的。父进程也可以通过调用CreateProcess指定参数来创建新的环境变量</p>
<h3 id="攻击进程的环境变量"><a href="#攻击进程的环境变量" class="headerlink" title="攻击进程的环境变量"></a>攻击进程的环境变量</h3><h4 id="修改PATH或者PATHEXT"><a href="#修改PATH或者PATHEXT" class="headerlink" title="修改PATH或者PATHEXT"></a>修改PATH或者PATHEXT</h4><p>​    可以修改PATH或者PATHEXT这个比较好理解，就是修改PATH或者PATHEXT的顺序使得当当要调用的时候先调用了恶意的软件</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030447307.png" srcset="/img/loading.gif" alt="image-20200310030447307"></p>
<p>变成：</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030501147.png" srcset="/img/loading.gif" alt="image-20200310030501147"></p>
<p>这样就会先找.tmp下的文件，然后在这里放一个恶意软件就可以得到执行</p>
<p>同理对PATHEXT</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030548250.png" srcset="/img/loading.gif" alt="image-20200310030548250"></p>
<p>变成:</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310030621734.png" srcset="/img/loading.gif" alt="image-20200310030621734"></p>
<p>这样执行一个比如calc的文件，首先执行calc.zzz再执行cala.com, 实现攻击。</p>
<h4 id="用环境变量作为标记"><a href="#用环境变量作为标记" class="headerlink" title="用环境变量作为标记"></a>用环境变量作为标记</h4><p>很多时候恶意软件通过一些可以全局访问的变量标志自己在系统中的存在(为了不被友军误伤)，就比如Coreflood这个恶意软件，他的核心是一个DLL，但是每个Process只要装载一次，所以对每个加载过的process添加一个独特的string到他的环境变量中去，每次上载之前先看一下有没有先加入这个string，若加入了不上载了。</p>
<h2 id="标准句柄"><a href="#标准句柄" class="headerlink" title="标准句柄"></a>标准句柄</h2><p>这个标准句柄准确翻译应该是: 标准输入输出异常处理的句柄。</p>
<p>分析这个句柄是很有用的(就比如我们的实验分析shelly.exe), 因为很多恶意的软件在系统上留后门的方式是这样的:比如在目标主机上开启一个程序,然后这个程序一直在监听某个特定的端口，如果端口来了请求，就新建一个命令行进程交给请求的客户端，然后主机继续监听。</p>
<p>注意到，敌手可以发起这个请求然后获得这个cmd，然后对系统进行肆意妄为。(实验shelly.exe原理就是这个)</p>
<h2 id="DLL"><a href="#DLL" class="headerlink" title="DLL"></a>DLL</h2><p>DLL全称Dynamic Link libraries，其中包含执行部分和资源，可以被进程加载并在之后享有进程的所有资源: 进程，句柄等等。也因此容易被攻击者利用。</p>
<p>我们在分析DLL的时候要注意:</p>
<ul>
<li>之前的三条链，注意他有没有故意去隐藏自己</li>
<li>奇怪的加载地址比如:C:\Windows\ system32\sys\kernel32.dll, 或者从非NTFS区加载进来的</li>
<li>上下文，比如notepad++加载ws2_32.dll 就会比较可疑</li>
</ul>
<h3 id="DLL加载"><a href="#DLL加载" class="headerlink" title="DLL加载"></a>DLL加载</h3><ul>
<li>每个.exe有一个IAT(import address table)来加载需要的dll</li>
<li>每个dll也有他自己依赖的dll</li>
<li>runtime load：loadlibiary() 允许程序在运行时加载dll</li>
<li>代码植入，dll被强行加载到目标进程中去</li>
</ul>
<p>​    获取加载的dll，现在微软提供了一些API供使用，也有一些现成的工具来直接用，但需要注意的是，这些工具用的都是遍历loadlist。</p>
<p>​    所以我们有时要看其他两条链防止攻击者把加载的dll在loadlist中隐藏了</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310112347365.png" srcset="/img/loading.gif" alt="image-20200310112347365"></p>
<p>我们看一下dlllist遍历这个loadlist的结果</p>
<p><img src="C:%5CUsers%5C79916%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200310105316251.png" srcset="/img/loading.gif" alt="image-20200310105316251"></p>
<p>​    可以看到.exe先加载，之后是相应的dll加载，注意到loadcount，这个值我们之前提到是指loadlibrary 加载他的次数其中0xffff是指-1，在这里意思是用IAT加载而不是通过loadlibrary</p>
<p>​    </p>
<h3 id="检测未连接的DLL"><a href="#检测未连接的DLL" class="headerlink" title="检测未连接的DLL"></a>检测未连接的DLL</h3><p>之前提到了从一条链上解除的技术，对于这个我们可以用其他两条链来交叉验证，但是现在也有了解除三条链的技术，所以必须要有新的方法来找这些隐藏的dll。</p>
<ul>
<li>PE file scan: 通过扫描内存中的PE实例，找PE实例可以通过找PE的特殊开头:MZ,但是由于依然是在用户空间，既然malware可以修改list， 他也是可以修改开头的。</li>
<li>VAD cross-referencing: VAD中包含了该段内存中对应到的硬盘中的映射，比如该段内存的内容包含了哪个文件以及文件的full path。VAD位于内核，所以不能被轻易修改</li>
</ul>
<p>介绍一下VAD cross-reference的插件: ldrmudles,</p>
<p>工作原理:</p>
<ol>
<li>首先在VAD中找大节点(往往存mapfile，dll) with PAGE_EXECUTE_WRITECOPY protections, a VadImageMap type, and the Image control flag set.</li>
<li>然后比较这个VAD节点中的address和在用户内存扫描得出的DllBase(位于_LDR_DATA_TABLE_ENTRY)</li>
<li>出现在VAD中但是不在扫描结果中的很有可能就是被hide了</li>
</ol>
<h2 id="内存中的PE文件"><a href="#内存中的PE文件" class="headerlink" title="内存中的PE文件"></a>内存中的PE文件</h2><p>书中首先指出很难在内存中dump出一份跟执行时一模一样的PE文件，但是提取出来的信息足够分析使用。</p>
<p>这里提取PE是因为很多PE进行pack，但是放在内存上就没有壳保护了，于是在内存取出来到硬盘上之后可以用于逆向分析</p>
<p>然后文中还提到了为什么不可以用内存中PE的hash跟硬盘上的hash进行比较得出是否被修改，有很多原因:</p>
<ul>
<li>IAT是被添加的(loadlibrary的调用)</li>
<li>一些section不一定是每次都加载到内存上去，比如.rsrc, 只有在访问的时候才加上去</li>
<li>存在松弛空间：松弛空间是指，一个section在内存中不一定是正好是一页的整数倍，所以为了对齐(保护方式是按页为单位的，所以不能一个页一部分可写另一部分标记位可写可读可执行)，内存中的PE相对于硬盘是存在很多松弛空间的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310131908736.png" srcset="/img/loading.gif" alt="image-20200310131908736"></p>
<h3 id="提取内存中PE的步骤"><a href="#提取内存中PE的步骤" class="headerlink" title="提取内存中PE的步骤"></a>提取内存中PE的步骤</h3><p>我们拿volshell下步骤作为例子</p>
<p><strong>Step 1.</strong> </p>
<p>首先用volshell attach到一个指定的进程上，获取该进程的实例，并从中得到PEB，从PEB得到ImageBaseAddress， 康康DOS头</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132756815.png" srcset="/img/loading.gif" alt="image-20200310132756815"></p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132822860.png" srcset="/img/loading.gif" alt="image-20200310132822860"></p>
<p><strong>Step 2.</strong></p>
<p>可以看到标准的签名MZ(4d5a), 然后通过这个头找到NT头</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310132931276.png" srcset="/img/loading.gif" alt="image-20200310132931276"></p>
<p><strong>Step 3.</strong></p>
<p>得到NT头之后，就豁然开朗了，从中得到各个section的偏移</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133128459.png" srcset="/img/loading.gif" alt="image-20200310133128459"></p>
<p><strong>Step 4.</strong></p>
<p>然后根据偏移把各个section写到硬盘上去即可</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133224747.png" srcset="/img/loading.gif" alt="image-20200310133224747"></p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310133232861.png" srcset="/img/loading.gif" alt="image-20200310133232861"></p>
<p>就得到了dumped.exe</p>
<h3 id="现有写好的PE提取插件"><a href="#现有写好的PE提取插件" class="headerlink" title="现有写好的PE提取插件"></a>现有写好的PE提取插件</h3><p>这些插件都是基于上面那个原理</p>
<ul>
<li><p>procdump: 有两个选项 –pid(通过上面的方法) 或者 –offset(通过_EPROCESS, 这个可以找到不在list中的进程)</p>
</li>
<li><p>dlldump: 这个跟procdump的类似但是是提取dll的</p>
</li>
<li><p>moddump: 读取kernel module</p>
<p>详见P242</p>
</li>
</ul>
<p>所有上面三个都需要提供 –dump-dir参数(写到哪里去) –memory(指定是否需要松弛空间)</p>
<p>例子:</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135136944.png" srcset="/img/loading.gif" alt="image-20200310135136944">  </p>
<p>这里文件的命名都是excutable.PID.exe</p>
<p>下面这个例子给出了不在pslist中的进程怎么提出来（其中的地址是通过_EPROCESS对象中读出来的):</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135638418.png" srcset="/img/loading.gif" alt="image-20200310135638418"></p>
<p>下面给出提取dll的例子，这里指定了提出名字中含有crypt的dll。</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135543480.png" srcset="/img/loading.gif" alt="image-20200310135543480"></p>
<p>但是对于一些注入或者隐藏的dll，你没法正常读出来因为不知道名字也不在list上，所以通过得到这个PE的位置然后往后扫描</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310135851589.png" srcset="/img/loading.gif" alt="image-20200310135851589"></p>
<hr>
<p><strong>Attention!</strong></p>
<p>注意到，不管是上面的插件也好或是直接遍历的方法也好，若是MZ被修改或是section的位置被修改都会导致出问题。我们可以通过使用vaddump把该进程的相关内存先提出来之后对这个内存做manual fix-up 然后再用IDA去分析</p>
<hr>
<h2 id="打包与压缩问题"><a href="#打包与压缩问题" class="headerlink" title="打包与压缩问题"></a>打包与压缩问题</h2><p>为了克服打包和压缩带来的混淆，往往是上载到内存用自带的解压程序解压之后再来分析</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310164832596.png" srcset="/img/loading.gif" alt="image-20200310164832596"></p>
<p>所以一般的套路是:</p>
<p>运行在虚拟机下运行：</p>
<ol>
<li>拍一个内存快照</li>
<li>使用procdump</li>
<li>使用string cat在内存中找字符串</li>
</ol>
<hr>
<p><strong>Question</strong></p>
<blockquote>
<p>The layers of obfuscation introduced by packed or compressed binaries are often removed when they load into memory. In almost all cases, before executing the main payload, a self-modifying program decompresses in place, or moves to another address and then decompresses.</p>
</blockquote>
<p>这个self-modifying程序是指什么呢?</p>
<hr>
<h2 id="Code-injection"><a href="#Code-injection" class="headerlink" title="Code injection"></a>Code injection</h2><p>文中把代码植入分为以下四种</p>
<ol>
<li>Remote DLL injection: 恶意进程强制目标进程去通过LoadLibrary从磁盘上加载DLL，但这种注入的前提是DLL必须在磁盘上。</li>
<li>Remote code injection: 恶意进程直接传代码块(shellcode)给目标进程</li>
<li>Reflective DLL injection: 恶意进程向目标进程内存空间中写入dll，这个dll自己初始化不需要windows的loader</li>
<li>Hollow process injection: 恶意进程首先启动一个新的合法的进程实例然后使其suspend，在这个进程恢复之前，他的内存空间是被挖空的，由恶意代码使用。</li>
</ol>
<p>下面介绍一下上面提到的几种注入:</p>
<p>以下进程A为恶意进程，B为目标进程</p>
<h3 id="远程DLL注入"><a href="#远程DLL注入" class="headerlink" title="远程DLL注入"></a>远程DLL注入</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>进程A将自己设置为debug程序(使能SE_DEBUG_PRIVILEGE)，这使得他可以对其他进程的内存进行读写就好像一个debugger</li>
<li>进程A通过OpenProcess打开一个进程B 的句柄, 打开的时候请求PROCESS_CREATE_THREAD, PROCESS_VM_OPERATION, PROCESS_VM_WRITE.</li>
</ol>
<hr>
<p>​        注: OpenProcess是打开一个现有的进程，返回其句柄，常用于进程之间的同步</p>
<hr>
<ol start="3">
<li>进程A通过VirtualAllocEx在B的内存中开辟页，页的保护级别设置为PAGE_READWRITE.</li>
<li>A向B传输一个string.txt（指出dll在硬盘上的位置），这个string放在之前一步开的空间里</li>
<li>A通过CreateRemoteThread在B中创建一个新的线程来执行LoadLibrary进而加载在前一步中传过来的dll位置</li>
<li>直到这一步，注入已经完成了，A把在第3步中开辟的空间free掉</li>
<li>A调用closeHandle清理现场跑路</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>对于这样一种注入，我们很难分辨出合理加入的dll和被注入的dll，因为不管从哪里看他们可能都是identical的，但总的来说，有这么两种方法来区分他们</p>
<ol>
<li>如果注入的dll尝试把自己隐藏起来(比如把自己从链上摘下)，这样就可以根据之前的两种方法来断定他是不是被注入的</li>
<li>如果被注入dll是被pack的，他需要开辟一块新空间，把解压代码copy过去执行进而执行</li>
</ol>
<p><em>这么说来，不作死就好好呆在那里反而最安全</em></p>
<h3 id="远程代码注入"><a href="#远程代码注入" class="headerlink" title="远程代码注入"></a>远程代码注入</h3><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>前两步跟DLL一样</p>
<ol start="3">
<li>A进程在B进程中分配一片PAGE_EXECUTE_READWRITE的内存，这使得A可以再这里胡作非为(可读可写可执行)</li>
<li>A传一个代码块给B</li>
<li>A在B中开一个新的线程去执行刚传的代码块</li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>介绍一下<strong>malfind</strong>插件！</p>
<p>先介绍一下malfind 判断是否为inject的标准(同时满足):</p>
<ul>
<li>有一片可读可写可执行的内存</li>
<li>这片内存是private的</li>
<li>所有的内存都是commit的</li>
<li>这篇内存存在CPU指令或者PE头</li>
</ul>
<hr>
<p><strong>Question:</strong></p>
<p>​    正常的代码区域不满足这些条件?</p>
<hr>
<p>我们看一下几个例子加深理解:</p>
<h5 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h5><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310180746809.png" srcset="/img/loading.gif" alt="image-20200310180746809"></p>
<p>这是malfind找到的一个片段但是我们不能判断他是不是真的注入代码，因为有些时候合理的代码也会满足这类条件。这里是找到了一个PE头</p>
<h5 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h5><p>接下来的并没有PE头，因为注入的是一块shellcode</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181049499.png" srcset="/img/loading.gif" alt="image-20200310181049499"></p>
<p>这个很可能是一块注入代码，因为其汇编语言在这里是make sense的，比如跳转地址合理</p>
<p>MOC EDI, EDI</p>
<p>PUSH EBP</p>
<p>代表即将函数调用</p>
<h5 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h5><p>再看一个正常代码但是被错判的:</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181319070.png" srcset="/img/loading.gif" alt="image-20200310181319070"></p>
<p>因为符合malfind的标准所以被找出来了，为什么说是错判呢，可以看到有Enter 没有 leave， 而且JNO之前没有比较，所以这是无意义的代码片段</p>
<h5 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h5><p>下面看一个恶意代码伪装自己的例子</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181603923.png" srcset="/img/loading.gif" alt="image-20200310181603923"></p>
<p>可以看到这里全是0，一眨眼以为是找错了，但是我们看下一页的时候就会发现端倪</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310181720248.png" srcset="/img/loading.gif" alt="image-20200310181720248"></p>
<p>这边就是恶意代码的主函数了。</p>
<hr>
<p><strong>Question：</strong><br>书上说这是函数开始，为啥没有call或者JMP啊，是我汇编没学好么 ？。？</p>
<hr>
<h4 id="总之"><a href="#总之" class="headerlink" title="总之"></a>总之</h4><p>使用malfind只是缩小范围，然后还要根据自己的经(xia)验(cai)和汇编只是来确定</p>
<h3 id="反射DLL注入"><a href="#反射DLL注入" class="headerlink" title="反射DLL注入"></a>反射DLL注入</h3><p>这是前两者的杂交，A向B传递了一个dll</p>
<p>他有两个优势:</p>
<ul>
<li>不需要提前在磁盘里写好，直接通过连接就可以把DLL送入加载区域</li>
<li>不要调用loadlibrary，也可以避免出现在那三条链中</li>
</ul>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310182809527.png" srcset="/img/loading.gif" alt="image-20200310182809527"></p>
<p>可以看得出来是满足malfind的查询条件的。所以也可以用malfind查询</p>
<h3 id="挖空注入"><a href="#挖空注入" class="headerlink" title="挖空注入"></a>挖空注入</h3><p>之前的三种方法都是在目标进程中开一个新线程来执行恶意代码，但是目标进程仍然是在执行的。这个方法是直接创建一个新的合法进程，在执行之前把其中合法进程的PE占的空间全部free掉，放入恶意代码，然后开始执行但是其他数据结构(PEB)是这个合法进程的，所以依旧会被认作这个合法进程</p>
<p><img src="https://raw.githubusercontent.com/Simplewyl2000/blogImg/master/image-20200310183531474.png" srcset="/img/loading.gif" alt="image-20200310183531474"></p>
<h4 id="如何挖空进程"><a href="#如何挖空进程" class="headerlink" title="如何挖空进程"></a>如何挖空进程</h4><ol>
<li>开启一个合法的新进程比如: C:\windows\system32\ lsass.exe, 但是把他的第一个线程给suspend，此时，PEB的相关数据都是lsass.exe</li>
<li>获取恶意代码，可以从硬盘上也可以从缓冲区中等等</li>
<li>找到lsass.exe的ImageBase，然后free掉所有的section。此时DLL,堆栈，句柄都是完好的，只不过PE被挖空了</li>
<li>在lasass.exe中开辟一个新的内存段(可读可写可执行)，然后返回imagebase(可以跟之前一样也可以不一样)</li>
<li>把恶意代码的PE header 放到这篇内存中去。</li>
<li>根据header中的section指示加载各个section</li>
<li>把那个suspend 的线程的开始位置指向刚加载的section中去(AddressOfEntryPoint)</li>
<li>开始执行, 在lsass.exe的容器中</li>
</ol>
<h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>我们从PEB上是看不出任何区别的</p>
<p>注意到他有重新分配内存所以我们应该从VAD的角度来考虑，查看VAD的相关信息，所以当看到有多个相同的进程的时候，比较他们的VAD信息尽管PEB中含的是合法进程的数据，但是VAD真实记录了所有发生在这段内存上的事情！详见P260(就是sample007.mem的解析)</p>
<p>所以我们可以看一下ldrmodules和VAD中的记录区别</p>
<hr>
<p><strong>Question:</strong></p>
<blockquote>
<p>Because lsass.exe was unmapped, a name is no longer associated with the region at 0x01000000. But calling NtUnmapViewOfSection (step 3) doesn’t cause the PEB to lose its metadata, so those structures still have a record of the original mapping in the load order and memory order lists P261</p>
</blockquote>
<p>没懂这段</p>
<hr>
<h2 id="处理dump-出来的内存文件"><a href="#处理dump-出来的内存文件" class="headerlink" title="处理dump 出来的内存文件"></a>处理dump 出来的内存文件</h2><p>​    就是说了下很多时候把dump出来的文件是要处理一下才能放到一些逆向软件中去的，当不清楚dump出的内存的时候，建议用一下impscan得到该文件的一些信息，这里书中也就是笼统的讲了一下。</p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/Memory-forensics/">Memory forensics</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
              
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/Windows/">Windows</a>
                
                  <a class="hover-with-bg" href="/tags/System/">System</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container">
        <div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>
      </div>
    
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>

    
  <div>
    
      <!-- 不蒜子统计PV -->
      
      <span id="busuanzi_container_site_pv" style="display: none">
      总访问量 <span id="busuanzi_value_site_pv"></span> 次
    </span>
    
    
      <!-- 不蒜子统计UV -->
      
      <span id="busuanzi_container_site_uv" style="display: none">
      总访客数 <span id="busuanzi_value_site_uv"></span> 人
    </span>
    
  </div>


    

    <!-- cnzz Analytics icon -->
    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var main = $('main');
      var tocT = navHeight + (toc.offset().top - main.offset().top);
      var tocLimMin = main.offset().top - navHeight;
      var tocLimMax = $('#comments').offset().top - navHeight;
      $(window).scroll(function () {
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;
        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': tocT,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
    });
  </script>







  <script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Hunting Malware&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
